diff --git a/app/build.gradle b/app/build.gradle
index 811d6a1..2e28a4a 100644
--- a/app/build.gradle
+++ b/app/build.gradle
@@ -22,7 +22,7 @@ android {
 	splits {
 		abi {
 			enable true
-			universalApk true
+			universalApk false
 		}
 	}
 
@@ -50,4 +50,16 @@ android {
 			}
 		}
 	}
+
+	Calendar origin = Calendar.getInstance()
+	origin.set(2021, Calendar.DECEMBER, 31, 23, 59)
+	Date d1 = origin.getTime()
+	Date d2 = new Date()
+	long minutes = (d2.getTime() - d1.getTime()) / 1000 / 60
+	def DateVersionCode = 2112312359 + minutes
+	android.applicationVariants.all { variant ->
+		variant.outputs.all { output ->
+			output.versionCodeOverride = DateVersionCode
+		}
+	}
 }
Submodule jni 57d2ace..ca3182b (rewind):
diff --git a/jni/build.gradle b/jni/build.gradle
index 33685a9..7416677 100644
--- a/jni/build.gradle
+++ b/jni/build.gradle
@@ -2,7 +2,7 @@ apply plugin: 'com.android.library'
 apply plugin: 'maven-publish'
 
 group = 'com.artifex.mupdf'
-version = '1.23.5'
+version = '1.23.4'
 
 buildscript {
 	repositories {
Submodule libmupdf 7dcd45f..05888bb (rewind):
diff --git a/jni/libmupdf/include/mupdf/fitz/version.h b/jni/libmupdf/include/mupdf/fitz/version.h
index 093fb688c..bec00823d 100644
--- a/jni/libmupdf/include/mupdf/fitz/version.h
+++ b/jni/libmupdf/include/mupdf/fitz/version.h
@@ -23,9 +23,9 @@
 #ifndef MUPDF_FITZ_VERSION_H
 #define MUPDF_FITZ_VERSION_H
 #ifndef FZ_VERSION
-#define FZ_VERSION "1.23.5"
+#define FZ_VERSION "1.23.4"
 #define FZ_VERSION_MAJOR 1
 #define FZ_VERSION_MINOR 23
-#define FZ_VERSION_PATCH 5
+#define FZ_VERSION_PATCH 4
 #endif
 #endif
diff --git a/jni/libmupdf/include/mupdf/pdf/cmap.h b/jni/libmupdf/include/mupdf/pdf/cmap.h
index cc4c58f42..4c1a5cc8c 100644
--- a/jni/libmupdf/include/mupdf/pdf/cmap.h
+++ b/jni/libmupdf/include/mupdf/pdf/cmap.h
@@ -103,8 +103,6 @@ void pdf_map_range_to_range(fz_context *ctx, pdf_cmap *cmap, unsigned int srclo,
 
 /*
 	Add a single one-to-many mapping.
-
-	len <= 256.
 */
 void pdf_map_one_to_many(fz_context *ctx, pdf_cmap *cmap, unsigned int one, int *many, size_t len);
 void pdf_sort_cmap(fz_context *ctx, pdf_cmap *cmap);
diff --git a/jni/libmupdf/pyproject.toml b/jni/libmupdf/pyproject.toml
index 6c14e94fb..4b1d7e3ac 100644
--- a/jni/libmupdf/pyproject.toml
+++ b/jni/libmupdf/pyproject.toml
@@ -1,5 +1,5 @@
 [build-system]
-requires = ["libclang", "swig", "setuptools"]
+requires = ["libclang", "swig"]
 
 # See pep-517.
 #
diff --git a/jni/libmupdf/scripts/jlib.py b/jni/libmupdf/scripts/jlib.py
index a6ded32f7..c562743e0 100644
--- a/jni/libmupdf/scripts/jlib.py
+++ b/jni/libmupdf/scripts/jlib.py
@@ -2178,7 +2178,7 @@ def build(
         except Exception:
             command0 = None
         if command != command0:
-           reasons.append( f'command has changed: {command0!r} => {command!r}')
+           reasons.append( 'command has changed')
 
     if not reasons or all_reasons:
         reason = fs_any_newer( infiles, outfiles)
@@ -2208,13 +2208,9 @@ def build(
     if os.path.exists( command_filename):
         fs_rename(command_filename, command_filename_temp)
     fs_update( command, command_filename_temp)
-    assert os.path.isfile( command_filename_temp)
 
     system( command, out=out, verbose=verbose, executable=executable, caller=2)
 
-    assert os.path.isfile( command_filename_temp), \
-            f'Command seems to have deleted {command_filename_temp=}: {command!r}'
-
     fs_rename( command_filename_temp, command_filename)
 
     return True
diff --git a/jni/libmupdf/scripts/mupdfwrap_test.cpp b/jni/libmupdf/scripts/mupdfwrap_test.cpp
deleted file mode 100644
index 177f1fd69..000000000
--- a/jni/libmupdf/scripts/mupdfwrap_test.cpp
+++ /dev/null
@@ -1,42 +0,0 @@
-#include "mupdf/fitz.h"
-#include "mupdf/classes.h"
-#include "mupdf/classes2.h"
-
-#include <assert.h>
-
-
-int main(int argc, char** argv)
-{
-    assert(argc == 2);
-    const char* path = argv[1];
-    mupdf::FzDocument document(path);
-    std::string v;
-    v = mupdf::fz_lookup_metadata2(document, "format");
-    printf("v=%s\n", v.c_str());
-    bool raised = false;
-    try
-    {
-        v = mupdf::fz_lookup_metadata2(document, "format___");
-    }
-    catch (std::exception& e)
-    {
-        raised = true;
-        printf("Received expected exception: %s\n", e.what());
-    }
-    if (!raised) exit(1);
-    printf("v=%s\n", v.c_str());
-    fz_rect r = fz_unit_rect;
-    printf("r.x0=%f\n", r.x0);
-
-    mupdf::FzStextOptions   options;
-    mupdf::FzStextPage stp( document, 0, options);
-    std::vector<fz_quad>    quads = mupdf::fz_highlight_selection2(
-            stp,
-            mupdf::FzPoint(20, 20),
-            mupdf::FzPoint(120, 220),
-            100
-            );
-    printf("quads.size()=%zi\n", quads.size());
-    assert(quads.size() == 13);
-    return 0;
-}
diff --git a/jni/libmupdf/scripts/mupdfwrap_test.py b/jni/libmupdf/scripts/mupdfwrap_test.py
index 7e0750735..4ce148538 100755
--- a/jni/libmupdf/scripts/mupdfwrap_test.py
+++ b/jni/libmupdf/scripts/mupdfwrap_test.py
@@ -165,7 +165,7 @@ def test(path):
     assert getattr(mupdf.FzBuffer, 'fz_buffer_extract')
     assert getattr(mupdf.FzBuffer, 'fz_buffer_extract_copy')
 
-    # Test SWIG Director wrapping of pdf_filter_options:
+    # Test SWIG Directory wrapping of pdf_filter_options:
     #
     test_filter(path)
 
@@ -355,12 +355,6 @@ def test(path):
 
         device_stext.fz_close_device()
 
-    # Check fz_search_page2().
-    items = mupdf.fz_search_page2(document, 0, "compression", 20)
-    print(f'{len(items)=}')
-    for item in items:
-        print(f'    {item.mark=} {item.quad=}')
-
     # Check copy-constructor.
     log(f'Checking copy-constructor')
     document2 = mupdf.FzDocument(document)
diff --git a/jni/libmupdf/scripts/pipcl.py b/jni/libmupdf/scripts/pipcl.py
index 18570f710..54ce4bd0c 100644
--- a/jni/libmupdf/scripts/pipcl.py
+++ b/jni/libmupdf/scripts/pipcl.py
@@ -1,595 +1,211 @@
 '''
-Python packaging operations, including PEP-517 support, for use by a `setup.py`
-script.
-
-The intention is to take care of as many packaging details as possible so that
-setup.py contains only project-specific information, while also giving as much
-flexibility as possible.
-
-For example we provide a function `build_extension()` that can be used to build
-a SWIG extension, but we also give access to the located compiler/linker so
-that a `setup.py` script can take over the details itself.
-
-Run doctests with: `python -m doctest pipcl.py`
+Support for Python packaging operations.
 '''
 
 import base64
-import glob
+import distutils.util
 import hashlib
-import inspect
 import io
 import os
 import platform
-import re
 import shutil
 import site
-import setuptools
 import subprocess
 import sys
-import sysconfig
 import tarfile
 import textwrap
 import time
 import zipfile
 
-import wdev
-
 
 class Package:
     '''
+    Helper for Python packaging operations.
+
     Our constructor takes a definition of a Python package similar to that
-    passed to `distutils.core.setup()` or `setuptools.setup()` (name, version,
-    summary etc) plus callbacks for building, getting a list of sdist
-    filenames, and cleaning.
-
-    We provide methods that can be used to implement a Python package's
-    `setup.py` supporting PEP-517.
-
-    We also support basic command line handling for use
-    with a legacy (pre-PEP-517) pip, as implemented
-    by legacy distutils/setuptools and described in:
-    https://pip.pypa.io/en/stable/reference/build-system/setup-py/
-
-    Here is a `doctest` example of using pipcl to create a SWIG extension
-    module. Requires `swig`.
-
-    Create an empty test directory:
-
-        >>> import os
-        >>> import shutil
-        >>> shutil.rmtree('pipcl_test', ignore_errors=1)
-        >>> os.mkdir('pipcl_test')
-
-    Create a `setup.py` which uses `pipcl` to define an extension module.
-
-        >>> import textwrap
-        >>> with open('pipcl_test/setup.py', 'w') as f:
-        ...     _ = f.write(textwrap.dedent("""
-        ...             import sys
-        ...             import pipcl
-        ...
-        ...             def build():
-        ...                 so_leaf = pipcl.build_extension(
-        ...                         name = 'foo',
-        ...                         path_i = 'foo.i',
-        ...                         outdir = 'build',
-        ...                         )
-        ...                 return [
-        ...                         ('build/foo.py', 'foo/__init__.py'),
-        ...                         (f'build/{so_leaf}', f'foo/'),
-        ...                         ('README', '$dist-info/'),
-        ...                         ]
-        ...
-        ...             def sdist():
-        ...                 return [
-        ...                         'foo.i',
-        ...                         'bar.i',
-        ...                         'setup.py',
-        ...                         'pipcl.py',
-        ...                         'wdev.py',
-        ...                         'README',
-        ...                         ]
-        ...
-        ...             p = pipcl.Package(
-        ...                     name = 'foo',
-        ...                     version = '1.2.3',
-        ...                     fn_build = build,
-        ...                     fn_sdist = sdist,
-        ...                     )
-        ...
-        ...             build_wheel = p.build_wheel
-        ...             build_sdist = p.build_sdist
-        ...
-        ...             # Handle old-style setup.py command-line usage:
-        ...             if __name__ == '__main__':
-        ...                 p.handle_argv(sys.argv)
-        ...             """))
-
-    Create the files required by the above `setup.py` - the SWIG `.i` input
-    file, the README file, and copies of `pipcl.py` and `wdev.py`.
-
-        >>> with open('pipcl_test/foo.i', 'w') as f:
-        ...     _ = f.write(textwrap.dedent("""
-        ...             %include bar.i
-        ...             %{
-        ...             #include <stdio.h>
-        ...             #include <string.h>
-        ...             int bar(const char* text)
-        ...             {
-        ...                 printf("bar(): text: %s\\\\n", text);
-        ...                 int len = (int) strlen(text);
-        ...                 printf("bar(): len=%i\\\\n", len);
-        ...                 fflush(stdout);
-        ...                 return len;
-        ...             }
-        ...             %}
-        ...             int bar(const char* text);
-        ...             """))
-
-        >>> with open('pipcl_test/bar.i', 'w') as f:
-        ...     _ = f.write( '\\n')
-
-        >>> with open('pipcl_test/README', 'w') as f:
-        ...     _ = f.write(textwrap.dedent("""
-        ...             This is Foo.
-        ...             """))
-
-        >>> root = os.path.dirname(__file__)
-        >>> _ = shutil.copy2(f'{root}/pipcl.py', 'pipcl_test/pipcl.py')
-        >>> _ = shutil.copy2(f'{root}/wdev.py', 'pipcl_test/wdev.py')
-
-    Use `setup.py`'s command-line interface to build and install the extension
-    module into root `pipcl_test/install`.
-
-        >>> _ = subprocess.run(
-        ...         f'cd pipcl_test && {sys.executable} setup.py --root install install',
-        ...         shell=1, check=1)
-
-    The actual install directory depends on `sysconfig.get_path('platlib')`:
-
-        >>> if windows():
-        ...     install_dir = 'pipcl_test/install'
-        ... else:
-        ...     install_dir = f'pipcl_test/install/{sysconfig.get_path("platlib").lstrip(os.sep)}'
-        >>> assert os.path.isfile( f'{install_dir}/foo/__init__.py')
-
-    Create a test script which asserts that Python function call `foo.bar(s)`
-    returns the length of `s`, and run it with `PYTHONPATH` set to the install
-    directory:
-
-        >>> with open('pipcl_test/test.py', 'w') as f:
-        ...     _ = f.write(textwrap.dedent("""
-        ...             import sys
-        ...             import foo
-        ...             text = 'hello'
-        ...             print(f'test.py: calling foo.bar() with text={text!r}')
-        ...             sys.stdout.flush()
-        ...             l = foo.bar(text)
-        ...             print(f'test.py: foo.bar() returned: {l}')
-        ...             assert l == len(text)
-        ...             """))
-        >>> r = subprocess.run(
-        ...         f'{sys.executable} pipcl_test/test.py',
-        ...         shell=1, check=1, text=1,
-        ...         stdout=subprocess.PIPE, stderr=subprocess.STDOUT,
-        ...         env=os.environ | dict(PYTHONPATH=install_dir),
-        ...         )
-        >>> print(r.stdout)
-        test.py: calling foo.bar() with text='hello'
-        bar(): text: hello
-        bar(): len=5
-        test.py: foo.bar() returned: 5
-        <BLANKLINE>
-
-    Check that building sdist and wheel succeeds. For now we don't attempt to
-    check that the sdist and wheel actually work.
-
-        >>> _ = subprocess.run(
-        ...         f'cd pipcl_test && {sys.executable} setup.py sdist',
-        ...         shell=1, check=1)
-
-        >>> _ = subprocess.run(
-        ...         f'cd pipcl_test && {sys.executable} setup.py bdist_wheel',
-        ...         shell=1, check=1)
-
-    Check that rebuild does nothing.
-
-        >>> t0 = os.path.getmtime('pipcl_test/build/foo.py')
-        >>> _ = subprocess.run(
-        ...         f'cd pipcl_test && {sys.executable} setup.py bdist_wheel',
-        ...         shell=1, check=1)
-        >>> t = os.path.getmtime('pipcl_test/build/foo.py')
-        >>> assert t == t0
-
-    Check that touching bar.i forces rebuild.
-
-        >>> os.utime('pipcl_test/bar.i')
-        >>> _ = subprocess.run(
-        ...         f'cd pipcl_test && {sys.executable} setup.py bdist_wheel',
-        ...         shell=1, check=1)
-        >>> t = os.path.getmtime('pipcl_test/build/foo.py')
-        >>> assert t > t0
-
-    Check that touching foo.i.cpp does not run swig, but does recompile/link.
-
-        >>> t0 = time.time()
-        >>> os.utime('pipcl_test/build/foo.i.cpp')
-        >>> _ = subprocess.run(
-        ...         f'cd pipcl_test && {sys.executable} setup.py bdist_wheel',
-        ...         shell=1, check=1)
-        >>> assert os.path.getmtime('pipcl_test/build/foo.py') <= t0
-        >>> so = glob.glob('pipcl_test/build/*.so')
-        >>> assert len(so) == 1
-        >>> so = so[0]
-        >>> assert os.path.getmtime(so) > t0
-
-    Wheels and sdists
-
-        Wheels:
-            We generate wheels according to:
-            https://packaging.python.org/specifications/binary-distribution-format/
-
-            * `{name}-{version}.dist-info/RECORD` uses sha256 hashes.
-            * We do not generate other `RECORD*` files such as
-              `RECORD.jws` or `RECORD.p7s`.
-            * `{name}-{version}.dist-info/WHEEL` has:
-
-              * `Wheel-Version: 1.0`
-              * `Root-Is-Purelib: false`
-            * No support for signed wheels.
-
-        Sdists:
-            We generate sdist's according to:
-            https://packaging.python.org/specifications/source-distribution-format/
+    passed to distutils.core.setup() or setuptools.setup() - name, version,
+    summary etc, plus callbacks for build, clean and sdist filenames.
+
+    We then provide methods that can be used to implement a Python package's
+    PEP-517 backend and/or minimal setup.py support for use with a legacy
+    (pre-PEP-517) pip.
+
+    A PEP-517 backend can be implemented with::
+
+        import pipcl
+        import subprocess
+
+        def build():
+            subprocess.check_call('cc -shared -fPIC -o foo.so foo.c')
+            return ['foo.py', 'foo.so']
+
+        def sdist():
+            return ['foo.py', 'foo.c', 'pyproject.toml', ...]
+
+        p = pipcl.Package('foo', '1.2.3', fn_build=build, fn_sdist=sdist, ...)
+
+        def build_wheel(wheel_directory, config_settings=None, metadata_directory=None):
+            return p.build_wheel(wheel_directory, config_settings, metadata_directory)
+
+        def build_sdist(sdist_directory, config_settings=None):
+            return p.build_sdist(sdist_directory, config_settings)
+
+    Work as a setup.py script by appending::
+
+        import sys
+        if __name__ == '__main__':
+            p.handle_argv(sys.argv)
+
     '''
     def __init__(self,
             name,
             version,
-            platform = None,
-            supported_platform = None,
+            root = None,
             summary = None,
             description = None,
-            description_content_type = None,
-            keywords = None,
-            home_page = None,
-            download_url = None,
+            classifiers = None,
             author = None,
             author_email = None,
-            maintainer = None,
-            maintainer_email = None,
+            url_docs = None,
+            url_home = None,
+            url_source = None,
+            url_tracker = None,
+            url_changelog = None,
+            keywords = None,
+            platform = None,
             license = None,
-            classifier = None,
-            requires_dist = None,
-            requires_python = None,
-            requires_external = None,
-            project_url = None,
-            provides_extra = None,
-
-            root = None,
+            license_files = None,
             fn_build = None,
             fn_clean = None,
             fn_sdist = None,
-            tag_python = None,
-            tag_abi = None,
-            tag_platform = None,
-
-            wheel_compression = zipfile.ZIP_DEFLATED,
-            wheel_compresslevel = None,
             ):
         '''
-        The initial args before `root` define the package
-        metadata and closely follow the definitions in:
-        https://packaging.python.org/specifications/core-metadata/
-
-        Args:
-
-            name:
-                A string, the name of the Python package.
-            version:
-                A string, the version of the Python package. Also see PEP-440
-                `Version Identification and Dependency Specification`.
-            platform:
-                A string or list of strings.
-            supported_platform:
-                A string or list of strings.
-            summary:
-                A string, short description of the package.
-            description:
-                A string, a detailed description of the package.
-            description_content_type:
-                A string describing markup of `description` arg. For example
-                `text/markdown; variant=GFM`.
-            keywords:
-                A string containing comma-separated keywords.
-            home_page:
-                URL of home page.
-            download_url:
-                Where this version can be downloaded from.
-            author:
-                Author.
-            author_email:
-                Author email.
-            maintainer:
-                Maintainer.
-            maintainer_email:
-                Maintainer email.
-            license:
-                A string containing the license text. Written into metadata
-                file `COPYING`. Is also written into metadata itself if not
-                multi-line.
-            classifier:
-                A string or list of strings. Also see:
-
-                * https://pypi.org/pypi?%3Aaction=list_classifiers
-                * https://pypi.org/classifiers/
-
-            requires_dist:
-                A string or list of strings. Also see PEP-508.
-            requires_python:
-                A string or list of strings.
-            requires_external:
-                A string or list of strings.
-            project_url:
-                A string or list of strings, each of the form: `{name}, {url}`.
-            provides_extra:
-                A string or list of strings.
-
-            root:
-                Root of package, defaults to current directory.
-
-            fn_build:
-                A function taking no args, or a single `config_settings` dict
-                arg (as described in PEP-517), that builds the package.
-
-                Should return a list of items; each item should be a tuple of
-                two strings `(from_, to_)`, or a single string `path` which is
-                treated as the tuple `(path, path)`.
-
-                `from_` should be the path to a file; if a relative path it is
-                assumed to be relative to `root`.
-
-                `to_` identifies what the file should be called within a wheel
-                or when installing. If `to_` ends with `/`, the leaf of `from_`
-                is appended to it.
-
-                Initial `$dist-info/` in `_to` is replaced by
-                `{name}-{version}.dist-info/`; this is useful for license files
-                etc.
-
-                Initial `$data/` in `_to` is replaced by
-                `{name}-{version}.data/`. We do not enforce particular
-                subdirectories, instead it is up to `fn_build()` to specify
-                specific subdirectories such as `purelib`, `headers`,
-                `scripts`, `data` etc.
-
-                If we are building a wheel (e.g. `python setup.py bdist_wheel`,
-                or PEP-517 pip calls `self.build_wheel()`), we add file `from_`
-                to the wheel archive with name `to_`.
-
-                If we are installing (e.g. `install` command in
-                the argv passed to `self.handle_argv()`), then
-                we copy `from_` to `{sitepackages}/{to_}`, where
-                `sitepackages` is the installation directory, the
-                default being `sysconfig.get_path('platlib')` e.g.
-                `myvenv/lib/python3.9/site-packages/`.
-
-            fn_clean:
-                A function taking a single arg `all_` that cleans generated
-                files. `all_` is true iff `--all` is in argv.
-
-                For safety and convenience, can also returns a list of
-                files/directory paths to be deleted. Relative paths are
-                interpreted as relative to `root`. All paths are asserted to be
-                within `root`.
-
-            fn_sdist:
-                A function taking no args, or a single `config_settings` dict
-                arg (as described in PEP517), that returns a list of paths for
-                files that should be copied into the sdist. Each item in the
-                list can also be a tuple `(from_, to_)`, where `from_` is the
-                path of a file and `to_` is its name within the sdist.
-
-                Relative paths are interpreted as relative to `root`. It is an
-                error if a path does not exist or is not a file.
-
-                It can be convenient to use `pipcl.git_items()`.
-
-                The specification for sdists requires that the list contains
-                `pyproject.toml`; we enforce this with a diagnostic rather than
-                raising an exception, to allow legacy command-line usage.
-
-            tag_python:
-                First element of wheel tag defined in PEP-425. If None we use
-                `cp{version}`.
-
-                For example if code works with any Python version, one can use
-                'py3'.
-
-            tag_abi:
-                Second element of wheel tag defined in PEP-425. If None we use
-                `none`.
-
-            tag_platform:
-                Third element of wheel tag defined in PEP-425. Default is
-                `os.environ('AUDITWHEEL_PLAT')` if set, otherwise derived
-                from `setuptools.distutils.util.get_platform()` (was
-                `distutils.util.get_platform()` as specified in the PEP), e.g.
-                `openbsd_7_0_amd64`.
-
-                For pure python packages use: `tag_platform=any`
-
-            wheel_compression:
-                Used as `zipfile.ZipFile()`'s `compression` parameter when
-                creating wheels.
-
-            wheel_compresslevel:
-                Used as `zipfile.ZipFile()`'s `compresslevel` parameter when
-                creating wheels.
-
+        name:
+            A string, the name of the Python package.
+        version:
+            A string containing only 0-9 and '.'.
+        root:
+            Root of package, defaults to current directory.
+        summary:
+            A string.
+        description:
+            A string.
+        classifiers:
+            A list of strings.
+        url_home:
+        url_source:
+        url_docs:
+        url_tracker:
+        url_changelog:
+            A string containing a URL.
+        keywords:
+            A string containing space-separated keywords.
+        platform:
+            A string, used in metainfo.
+        license:
+            License text.
+        license_files:
+            List of string names of license files.
+        fn_build:
+            A function taking no args that builds the package.
+
+            Should return a list of items; each item should be a tuple of two
+            strings `(from_, to_)` or a single string `path` which is treated
+            as the tuple `(path, path)`.
+
+            `from_` should be the path to a file; if a relative path it is
+            assumed to be relative to `root`. `to_` identifies what the file
+            should be called within a wheel or when installing.
+
+            If we are building a wheel (e.g. 'bdist_wheel' in the argv passed
+            to `self.handle_argv()` or PEP-517 pip calls `self.build_wheel()`),
+            we copy file `from_` to `to_` inside the wheel archive.
+
+            If we are installing (e.g. 'install' command in the argv
+            passed to `self.handle_argv()`), we copy `from_` to
+            `sitepackages`/`to_`, where `sitepackages` is the first item in
+            `site.getsitepackages()[]` that exists.
+        fn_clean:
+            A function taking a single arg `all_` that cleans generated files.
+            `all_` is true iff '--all' is in argv.
+
+            For safety and convenience, can also returns a list of
+            files/directory paths to be deleted. Relative paths are interpreted
+            as relative to `root`. Paths are asserted to be within `root`.
+        fn_sdist:
+            A function taking no args that returns a list of paths, e.g. using
+            `pipcl.git_items()`, for files that should be copied into the
+            sdist. Relative paths are interpreted as relative to `root`. It is
+            an error if a path does not exist or is not a file.
         '''
-        assert name
-        assert version
-
-        def assert_str( v):
-            if v is not None:
-                assert isinstance( v, str), f'Not a string: {v!r}'
-        def assert_str_or_multi( v):
-            if v is not None:
-                assert isinstance( v, (str, tuple, list)), f'Not a string, tuple or list: {v!r}'
-
-        assert_str( name)
-        assert_str( version)
-        assert_str_or_multi( platform)
-        assert_str_or_multi( supported_platform)
-        assert_str( summary)
-        assert_str( description)
-        assert_str( description_content_type)
-        assert_str( keywords)
-        assert_str( home_page)
-        assert_str( download_url)
-        assert_str( author)
-        assert_str( author_email)
-        assert_str( maintainer)
-        assert_str( maintainer_email)
-        assert_str( license)
-        assert_str_or_multi( classifier)
-        assert_str_or_multi( requires_dist)
-        assert_str( requires_python)
-        assert_str_or_multi( requires_external)
-        assert_str_or_multi( project_url)
-        assert_str_or_multi( provides_extra)
-
-        # https://packaging.python.org/en/latest/specifications/core-metadata/.
-        assert re.match('([A-Z0-9]|[A-Z0-9][A-Z0-9._-]*[A-Z0-9])$', name, re.IGNORECASE), \
-                f'Bad name: {name!r}'
-
-
-        # PEP-440.
-        assert re.match(
-                    r'^([1-9][0-9]*!)?(0|[1-9][0-9]*)(\.(0|[1-9][0-9]*))*((a|b|rc)(0|[1-9][0-9]*))?(\.post(0|[1-9][0-9]*))?(\.dev(0|[1-9][0-9]*))?$',
-                    version,
-                ), \
-                f'Bad version: {version!r}.'
-
-        # https://packaging.python.org/en/latest/specifications/binary-distribution-format/
-        if tag_python:
-            assert '-' not in tag_python
-        if tag_abi:
-            assert '-' not in tag_abi
-        if tag_platform:
-            assert '-' not in tag_platform
-
         self.name = name
         self.version = version
-        self.platform = platform
-        self.supported_platform = supported_platform
+        self.root_sep = os.path.abspath(root if root else os.getcwd()) + os.sep
         self.summary = summary
         self.description = description
-        self.description_content_type = description_content_type
-        self.keywords = keywords
-        self.home_page = home_page
-        self.download_url = download_url
+        self.classifiers = classifiers
         self.author = author
         self.author_email  = author_email
-        self.maintainer = maintainer
-        self.maintainer_email = maintainer_email
+        self.url_docs = url_docs
+        self.url_home  = url_home
+        self.url_source = url_source
+        self.url_tracker = url_tracker
+        self.url_changelog = url_changelog
+        self.keywords = keywords
+        self.platform = platform
         self.license = license
-        self.classifier = classifier
-        self.requires_dist = requires_dist
-        self.requires_python = requires_python
-        self.requires_external = requires_external
-        self.project_url = project_url
-        self.provides_extra = provides_extra
-
-        self.root = os.path.abspath(root if root else os.getcwd())
+        self.license_files = license_files
         self.fn_build = fn_build
         self.fn_clean = fn_clean
         self.fn_sdist = fn_sdist
-        self.tag_python = tag_python
-        self.tag_abi = tag_abi
-        self.tag_platform = tag_platform
 
-        self.wheel_compression = wheel_compression
-        self.wheel_compresslevel = wheel_compresslevel
 
-
-    def build_wheel(self,
-            wheel_directory,
-            config_settings=None,
-            metadata_directory=None,
-            ):
+    def build_wheel(self, wheel_directory, config_settings=None, metadata_directory=None):
         '''
-        A PEP-517 `build_wheel()` function.
+        Helper for implementing a PEP-517 backend's `build_wheel()` function.
 
-        Also called by `handle_argv()` to handle the `bdist_wheel` command.
+        Also called by `handle_argv()` to handle the 'bdist_wheel' command.
 
         Returns leafname of generated wheel within `wheel_directory`.
         '''
-        log2(
-                f' wheel_directory={wheel_directory!r}'
-                f' config_settings={config_settings!r}'
-                f' metadata_directory={metadata_directory!r}'
+        _log('build_wheel():'
+                f' wheel_directory={wheel_directory}'
+                f' config_settings={config_settings}'
+                f' metadata_directory={metadata_directory}'
                 )
 
-        # Get two-digit python version, e.g. 'cp3.8' for python-3.8.6.
-        #
-        if self.tag_python:
-            tag_python = self.tag_python
-        else:
-            tag_python = 'cp' + ''.join(platform.python_version().split('.')[:2])
-
-        # ABI tag.
-        if self.tag_abi:
-            tag_abi = self.tag_abi
-        else:
-            tag_abi = 'none'
+        _log('build_wheel(): os.environ is:')
+        for n in sorted( os.environ.keys()):
+            v = os.environ[ n]
+            _log( f'    {n}: {v!r}')
 
-        # Find platform tag used in wheel filename.
+        # Find platform tag used in wheel filename, as described in
+        # PEP-0425. E.g. 'openbsd_6_8_amd64', 'win_amd64' or 'win32'.
         #
-        tag_platform = None
-        if not tag_platform:
-            tag_platform = self.tag_platform
-        if not tag_platform:
-            # Prefer this to PEP-425. Appears to be undocumented,
-            # but set in manylinux docker images and appears
-            # to be used by cibuildwheel and auditwheel, e.g.
-            # https://github.com/rapidsai/shared-action-workflows/issues/80
-            tag_platform = os.environ.get( 'AUDITWHEEL_PLAT')
-        if not tag_platform:
-            # PEP-425. On Linux gives `linux_x86_64` which is rejected by
-            # pypi.org.
-            #
-            tag_platform = setuptools.distutils.util.get_platform().replace('-', '_').replace('.', '_')
+        tag_platform = distutils.util.get_platform().replace('-', '_').replace('.', '_')
 
-            # We need to patch things on MacOS.
-            #
-            # E.g. `foo-1.2.3-cp311-none-macosx_13_x86_64.whl`
-            # causes `pip` to fail with: `not a supported wheel on this
-            # platform`. We seem to need to add `_0` to the OS version.
-            #
-            m = re.match( '^(macosx_[0-9]+)(_[^0-9].+)$', tag_platform)
-            if m:
-                tag_platform2 = f'{m.group(1)}_0{m.group(2)}'
-                log2( f'Changing from {tag_platform!r} to {tag_platform2!r}')
-                tag_platform = tag_platform2
+        # Get two-digit python version, e.g. 3.8 for python-3.8.6.
+        #
+        tag_python = ''.join(platform.python_version().split('.')[:2])
 
         # Final tag is, for example, 'cp39-none-win32', 'cp39-none-win_amd64'
         # or 'cp38-none-openbsd_6_8_amd64'.
         #
-        tag = f'{tag_python}-{tag_abi}-{tag_platform}'
+        tag = f'cp{tag_python}-none-{tag_platform}'
 
         path = f'{wheel_directory}/{self.name}-{self.version}-{tag}.whl'
 
         # Do a build and get list of files to copy into the wheel.
         #
-        items = list()
+        items = []
         if self.fn_build:
-            items = self._call_fn_build(config_settings)
+            _log(f'calling self.fn_build={self.fn_build}')
+            items = self.fn_build()
 
-        log2(f'Creating wheel: {path}')
+        _log(f'build_wheel(): Writing wheel {path} ...')
         os.makedirs(wheel_directory, exist_ok=True)
         record = _Record()
-        with zipfile.ZipFile(path, 'w', self.wheel_compression, self.wheel_compresslevel) as z:
+        with zipfile.ZipFile(path, 'w', zipfile.ZIP_DEFLATED) as z:
 
             def add_file(from_, to_):
                 z.write(from_, to_)
@@ -599,145 +215,117 @@ class Package:
                 z.writestr(to_, content)
                 record.add_content(content, to_)
 
-            dist_info_dir = self._dist_info_dir()
-
             # Add the files returned by fn_build().
             #
             for item in items:
                 (from_abs, from_rel), (to_abs, to_rel) = self._fromto(item)
                 add_file(from_abs, to_rel)
 
+            dist_info_path = f'{self.name}-{self.version}.dist-info'
             # Add <name>-<version>.dist-info/WHEEL.
             #
             add_str(
                     f'Wheel-Version: 1.0\n'
-                    f'Generator: pipcl\n'
+                    f'Generator: bdist_wheel\n'
                     f'Root-Is-Purelib: false\n'
                     f'Tag: {tag}\n'
                     ,
-                    f'{dist_info_dir}/WHEEL',
+                    f'{dist_info_path}/WHEEL',
                     )
             # Add <name>-<version>.dist-info/METADATA.
             #
-            add_str(self._metainfo(), f'{dist_info_dir}/METADATA')
-
-            # Add <name>-<version>.dist-info/COPYING.
-            if self.license:
-                add_str(self.license, f'{dist_info_dir}/COPYING')
+            add_str(self._metainfo(), f'{dist_info_path}/METADATA')
+            if self.license_files:
+                for license_file in self.license_files:
+                    (from_abs, from_to), (to_abs, to_rel) = self._fromto(license_file)
+                    add_file(from_abs, f'{dist_info_path}/{to_rel}')
 
             # Update <name>-<version>.dist-info/RECORD. This must be last.
             #
-            z.writestr(f'{dist_info_dir}/RECORD', record.get(f'{dist_info_dir}/RECORD'))
-
-        st = os.stat(path)
-        log1( f'Have created wheel size={st.st_size}: {path}')
-        if g_verbose >= 2:
-            with zipfile.ZipFile(path, compression=self.wheel_compression) as z:
-                log2(f'Contents are:')
-                for zi in sorted(z.infolist(), key=lambda z: z.filename):
-                    log2(f'    {zi.file_size: 10d} {zi.filename}')
+            z.writestr(f'{dist_info_path}/RECORD', record.get())
 
+        _log( f'build_wheel(): Have created wheel: {path}')
         return os.path.basename(path)
 
 
-    def build_sdist(self,
-            sdist_directory,
-            formats,
-            config_settings=None,
-            ):
+    def build_sdist(self, sdist_directory, config_settings=None):
         '''
-        A PEP-517 `build_sdist()` function.
+        Helper for implementing a PEP-517 backend's `build_sdist()` function.
 
-        Also called by `handle_argv()` to handle the `sdist` command.
+        [Though as of 2021-03-24 pip doesn't actually seem to ever call the
+        backend's `build_sdist()` function?]
+
+        Also called by `handle_argv()` to handle the 'sdist' command.
 
         Returns leafname of generated archive within `sdist_directory`.
         '''
-        log2(
-                f' sdist_directory={sdist_directory!r}'
-                f' formats={formats!r}'
-                f' config_settings={config_settings!r}'
-                )
-        if formats and formats != 'gztar':
-            raise Exception( f'Unsupported: formats={formats}')
-        items = list()
+        paths = []
         if self.fn_sdist:
-            if inspect.signature(self.fn_sdist).parameters:
-                items = self.fn_sdist(config_settings)
-            else:
-                items = self.fn_sdist()
+            paths = self.fn_sdist()
 
         manifest = []
-        names_in_tar = []
-        def check_name(name):
-            if name in names_in_tar:
-                raise Exception(f'Name specified twice: {name}')
-            names_in_tar.append(name)
-
-        prefix = f'{self.name}-{self.version}'
-        def add_content(tar, name, contents):
+        def add(tar, name, contents):
             '''
             Adds item called `name` to `tarfile.TarInfo` `tar`, containing
             `contents`. If contents is a string, it is encoded using utf8.
             '''
-            log2( f'Adding: {name}')
             if isinstance(contents, str):
                 contents = contents.encode('utf8')
-            check_name(name)
-            ti = tarfile.TarInfo(f'{prefix}/{name}')
+            ti = tarfile.TarInfo(name)
             ti.size = len(contents)
             ti.mtime = time.time()
             tar.addfile(ti, io.BytesIO(contents))
 
-        def add_file(tar, path_abs, name):
-            log2( f'Adding file: {os.path.relpath(path_abs)} => {name}')
-            check_name(name)
-            tar.add( path_abs, f'{prefix}/{name}', recursive=False)
-
         os.makedirs(sdist_directory, exist_ok=True)
-        tarpath = f'{sdist_directory}/{prefix}.tar.gz'
-        log2(f'Creating sdist: {tarpath}')
+        tarpath = f'{sdist_directory}/{self.name}-{self.version}.tar.gz'
+        _log(f'build_sdist(): Writing sdist {tarpath} ...')
         with tarfile.open(tarpath, 'w:gz') as tar:
-            found_pyproject_toml = False
-            for item in items:
-                (from_abs, from_rel), (to_abs, to_rel) = self._fromto(item)
-                if from_abs.startswith(f'{os.path.abspath(sdist_directory)}/'):
-                    # Source files should not be inside <sdist_directory>.
-                    assert 0, f'Path is inside sdist_directory={sdist_directory}: {from_abs!r}'
-                assert os.path.exists(from_abs), f'Path does not exist: {from_abs!r}'
-                assert os.path.isfile(from_abs), f'Path is not a file: {from_abs!r}'
-                if to_rel == 'pyproject.toml':
-                    found_pyproject_toml = True
-                add_file( tar, from_abs, to_rel)
-                manifest.append(to_rel)
-            if not found_pyproject_toml:
-                log0(f'Warning: no pyproject.toml specified.')
-
-            # Always add a PKG-INFO file.
-            add_content(tar, f'PKG-INFO', self._metainfo())
-
-            if self.license:
-                if 'COPYING' in names_in_tar:
-                    log2(f'Not writing .license because file already in sdist: COPYING')
-                else:
-                    add_content(tar, f'COPYING', self.license)
-
-        log1( f'Have created sdist: {tarpath}')
-        return os.path.basename(tarpath)
-
+            for path in paths:
+                path_abs, path_rel = self._path_relative_to_root( path)
+                if path_abs.startswith(f'{os.path.abspath(sdist_directory)}/'):
+                    # Ignore files inside <sdist_directory>.
+                    assert 0, f'Path is inside sdist_directory={sdist_directory}: {path_abs!r}'
+                if not os.path.exists(path_abs):
+                    assert 0, f'Path does not exist: {path_abs!r}'
+                if not os.path.isfile(path_abs):
+                    assert 0, f'Path is not a file: {path_abs!r}'
+                #log(f'path={path}')
+                tar.add( path_abs, f'{self.name}-{self.version}/{path_rel}', recursive=False)
+                manifest.append(path_rel)
+            add(tar, f'{self.name}-{self.version}/PKG-INFO', self._metainfo())
+
+            # It doesn't look like MANIFEST or setup.cfg are required?
+            #
+            if 0:
+                # Add manifest:
+                add(tar, f'{self.name}-{self.version}/MANIFEST', '\n'.join(manifest))
 
-    def _call_fn_build( self, config_settings=None):
-        assert self.fn_build
-        log2(f'calling self.fn_build={self.fn_build}')
-        if inspect.signature(self.fn_build).parameters:
-            ret = self.fn_build(config_settings)
-        else:
-            ret = self.fn_build()
-        assert isinstance( ret, (list, tuple)), \
-                f'Expected list/tuple from {self.fn_build} but got: {ret!r}'
-        return ret
+            if 0:
+                # add setup.cfg
+                setup_cfg = ''
+                setup_cfg += '[bdist_wheel]\n'
+                setup_cfg += 'universal = 1\n'
+                setup_cfg += '\n'
+                setup_cfg += '[flake8]\n'
+                setup_cfg += 'max-line-length = 100\n'
+                setup_cfg += 'ignore = F821\n'
+                setup_cfg += '\n'
+                setup_cfg += '[metadata]\n'
+                setup_cfg += 'license_file = LICENSE\n'
+                setup_cfg += '\n'
+                setup_cfg += '[tool:pytest]\n'
+                setup_cfg += 'minversion = 2.2.0\n'
+                setup_cfg += '\n'
+                setup_cfg += '[egg_info]\n'
+                setup_cfg += 'tag_build = \n'
+                setup_cfg += 'tag_date = 0\n'
+                add(tar, f'{self.name}-{self.version}/setup.cfg', setup_cfg)
+
+        _log( f'build_sdist(): Have created sdist: {tarpath}')
+        return os.path.basename(tarpath)
 
 
-    def _argv_clean(self, all_):
+    def argv_clean(self, all_):
         '''
         Called by `handle_argv()`.
         '''
@@ -748,79 +336,61 @@ class Package:
             if isinstance(paths, str):
                 paths = paths,
             for path in paths:
-                if not os.path.isabs(path):
-                    path = ps.path.join(self.root, path)
                 path = os.path.abspath(path)
-                assert path.startswith(self.root+os.sep), \
-                        f'path={path!r} does not start with root={self.root+os.sep!r}'
-                log2(f'Removing: {path}')
+                assert path.startswith(self.root_sep), \
+                        f'path={path!r} does not start with root={self.root_sep!r}'
+                _log(f'Removing: {path}')
                 shutil.rmtree(path, ignore_errors=True)
 
 
-    def install(self, record_path=None, root=None):
+    def argv_install(self, record_path):
         '''
-        Called by `handle_argv()` to handle `install` command..
+        Called by `handle_argv()`.
         '''
-        log2( f'{record_path=} {root=}')
-
-        # Do a build and get list of files to install.
-        #
-        items = list()
+        items = []
         if self.fn_build:
-            items = self._call_fn_build( dict())
-
-        root2 = install_dir(root)
-        log2( f'{root2=}')
-
-        log1( f'Installing into: {root2!r}')
-        dist_info_dir = self._dist_info_dir()
+            items = self.fn_build()
 
-        if not record_path:
-            record_path = f'{root2}/{dist_info_dir}/RECORD'
-        record = _Record()
-
-        def add_file(from_abs, from_rel, to_abs, to_rel):
-            log2(f'Copying from {from_rel} to {to_abs}')
-            os.makedirs( os.path.dirname( to_abs), exist_ok=True)
-            shutil.copy2( from_abs, to_abs)
-            record.add_file(from_rel, to_rel)
-
-        def add_str(content, to_abs, to_rel):
-            log2( f'Writing to: {to_abs}')
-            os.makedirs( os.path.dirname( to_abs), exist_ok=True)
-            with open( to_abs, 'w') as f:
-                f.write( content)
-            record.add_content(content, to_rel)
+        # We install to the first item in site.getsitepackages()[] that exists.
+        #
+        sitepackages_all = site.getsitepackages()
+        for p in sitepackages_all:
+            if os.path.exists(p):
+                sitepackages = p
+                break
+        else:
+            text = 'No item exists in site.getsitepackages():\n'
+            for i in sitepackages_all:
+                text += f'    {i}\n'
+            raise Exception(text)
 
+        record = _Record() if record_path else None
         for item in items:
             (from_abs, from_rel), (to_abs, to_rel) = self._fromto(item)
-            to_abs2 = f'{root2}/{to_rel}'
-            add_file( from_abs, from_rel, to_abs2, to_rel)
-
-        add_str( self._metainfo(), f'{root2}/{dist_info_dir}/METADATA', f'{dist_info_dir}/METADATA')
+            to_path = f'{sitepackages}/{to_rel}'
+            _log(f'copying from {from_abs} to {to_path}')
+            shutil.copy2( from_abs, f'{to_path}')
+            if record:
+                # Could maybe use relative path of to_path from sitepackages/.
+                record.add_file(from_abs, to_path)
 
-        log2( f'Writing to: {record_path}')
-        with open(record_path, 'w') as f:
-            f.write(record.get())
+        if record:
+            with open(record_path, 'w') as f:
+                f.write(record.get())
 
-        log2(f'Finished.')
+        _log(f'argv_install(): Finished.')
 
 
-    def _argv_dist_info(self, root):
+    def argv_dist_info(self, egg_base):
         '''
         Called by `handle_argv()`. There doesn't seem to be any documentation
-        for `setup.py dist_info`, but it appears to be like `egg_info` except
-        it writes to a slightly different directory.
+        for 'setup.py dist_info', but it appears to be like 'egg_info' except it
+        writes to a slightly different directory.
         '''
-        if root is None:
-            root = f'{self.name}-{self.version}.dist-info'
-        self._write_info(f'{root}/METADATA')
-        if self.license:
-            with open( f'{root}/COPYING', 'w') as f:
-                f.write( self.license)
+        self._write_info(f'{egg_base}/{self.name}.dist-info')
 
 
-    def _argv_egg_info(self, egg_base):
+    def argv_egg_info(self, egg_base):
         '''
         Called by `handle_argv()`.
         '''
@@ -831,13 +401,13 @@ class Package:
 
     def _write_info(self, dirpath=None):
         '''
-        Writes egg/dist info to files in directory `dirpath` or `self.root` if
-        `None`.
+        Writes egg/dist info to files in directory `dirpath` or `self.root_sep`
+        if `None`.
         '''
         if dirpath is None:
-            dirpath = self.root
-        log2(f'Creating files in directory {dirpath}')
-        os.makedirs(dirpath, exist_ok=True)
+            dirpath = self.root_sep
+        _log(f'_write_info(): creating files in directory {dirpath}')
+        os.mkdir(dirpath)
         with open(os.path.join(dirpath, 'PKG-INFO'), 'w') as f:
             f.write(self._metainfo())
 
@@ -855,14 +425,12 @@ class Package:
 
     def handle_argv(self, argv):
         '''
-        Attempt to handles old-style (pre PEP-517) command line passed by
-        old releases of pip to a `setup.py` script, and manual running of
-        `setup.py`.
+        Handles old-style (pre PEP-517) command line passed by old releases of pip to a
+        `setup.py` script.
 
-        This is partial support at best.
+        We only handle those args that seem to be used by pre-PEP-517 pip.
         '''
-        global g_verbose
-        #log2(f'argv: {argv}')
+        #_log(f'handle_argv(): argv: {argv}')
 
         class ArgsRaise:
             pass
@@ -889,10 +457,8 @@ class Package:
         opt_all = None
         opt_dist_dir = 'dist'
         opt_egg_base = None
-        opt_formats = None
         opt_install_headers = None
         opt_record = None
-        opt_root = None
 
         args = Args(argv[1:])
 
@@ -902,10 +468,10 @@ class Package:
                 break
 
             elif arg in ('-h', '--help', '--help-commands'):
-                log0(textwrap.dedent('''
+                _log(textwrap.dedent('''
                         Usage:
                             [<options>...] <command> [<options>...]
-                        Commands:
+                        commands:
                             bdist_wheel
                                 Creates a wheel called
                                 <dist-dir>/<name>-<version>-<details>.whl, where
@@ -913,19 +479,20 @@ class Package:
                                 and <details> encodes ABI and platform etc.
                             clean
                                 Cleans build files.
-                            dist_info
-                                Creates files in <name>-<version>.dist-info/ or
-                                directory specified by --egg-base.
                             egg_info
-                                Creates files in .egg-info/ or directory
-                                directory specified by --egg-base.
+                                Creates files in <egg-base>/.egg-info/, where
+                                <egg-base> is as specified with --egg-base.
                             install
-                                Builds and installs. Writes installation
-                                information to <record> if --record was
-                                specified.
+                                Installs into location from Python's
+                                site.getsitepackages() array. Writes installation
+                                information to <record> if --record
+                                was specified.
                             sdist
                                 Make a source distribution:
                                     <dist-dir>/<name>-<version>.tar.gz
+                            dist_info
+                                Like <egg_info> but creates files in
+                                <egg-base>/<name>.dist-info/
                         Options:
                             --all
                                 Used by "clean".
@@ -935,25 +502,14 @@ class Package:
                                 Default is "dist".
                             --egg-base <egg-base>
                                 Used by "egg_info".
-                            --formats <formats>
-                                Used by "sdist".
                             --install-headers <directory>
                                 Ignored.
                             --python-tag <python-tag>
                                 Ignored.
                             --record <record>
                                 Used by "install".
-                            --root <path>
-                                Used by "install".
                             --single-version-externally-managed
                                 Ignored.
-                            --verbose -v
-                                Extra diagnostics.
-                        Other:
-                            windows-vs [-y <year>] [-v <version>] [-g <grade] [--verbose]
-                                Windows only; looks for matching Visual Studio.
-                            windows-python [-v <version>] [--verbose]
-                                Windows only; looks for matching Python.
                         '''))
                 return
 
@@ -965,112 +521,54 @@ class Package:
             elif arg == '--compile':                            pass
             elif arg == '--dist-dir' or arg == '-d':            opt_dist_dir = args.next()
             elif arg == '--egg-base':                           opt_egg_base = args.next()
-            elif arg == '--formats':                            opt_formats = args.next()
             elif arg == '--install-headers':                    opt_install_headers = args.next()
             elif arg == '--python-tag':                         pass
             elif arg == '--record':                             opt_record = args.next()
-            elif arg == '--root':                               opt_root = args.next()
             elif arg == '--single-version-externally-managed':  pass
-            elif arg == '--verbose' or arg == '-v':             g_verbose += 1
-
-            elif arg == 'windows-vs':
-                command = arg
-                break
-            elif arg == 'windows-python':
-                command = arg
-                break
             else:
                raise Exception(f'Unrecognised arg: {arg}')
 
         assert command, 'No command specified'
 
-        log1(f'Handling command={command}')
+        _log(f'handle_argv(): Handling command={command}')
         if 0:   pass
         elif command == 'bdist_wheel':  self.build_wheel(opt_dist_dir)
-        elif command == 'clean':        self._argv_clean(opt_all)
-        elif command == 'dist_info':    self._argv_dist_info(opt_egg_base)
-        elif command == 'egg_info':     self._argv_egg_info(opt_egg_base)
-        elif command == 'install':      self.install(opt_record, opt_root)
-        elif command == 'sdist':        self.build_sdist(opt_dist_dir, opt_formats)
-
-        elif command == 'windows-python':
-            version = None
-            while 1:
-                arg = args.next(None)
-                if arg is None:
-                    break
-                elif arg == '-v':
-                    version = args.next()
-                elif arg == '--verbose':
-                    g_verbose += 1
-                else:
-                    assert 0, f'Unrecognised {arg=}'
-            python = wdev.WindowsPython(version=version)
-            print(f'Python is:\n{python.description_ml("    ")}')
-
-        elif command == 'windows-vs':
-            grade = None
-            version = None
-            year = None
-            while 1:
-                arg = args.next(None)
-                if arg is None:
-                    break
-                elif arg == '-g':
-                    grade = args.next()
-                elif arg == '-v':
-                    version = args.next()
-                elif arg == '-y':
-                    year = args.next()
-                elif arg == '--verbose':
-                    g_verbose += 1
-                else:
-                    assert 0, f'Unrecognised {arg=}'
-            vs = wdev.WindowsVS(year=year, grade=grade, version=version)
-            print(f'Visual Studio is:\n{vs.description_ml("    ")}')
-
+        elif command == 'clean':        self.argv_clean(opt_all)
+        elif command == 'dist_info':    self.argv_dist_info(opt_egg_base)
+        elif command == 'egg_info':     self.argv_egg_info(opt_egg_base)
+        elif command == 'install':      self.argv_install(opt_record)
+        elif command == 'sdist':        self.build_sdist(opt_dist_dir)
         else:
             assert 0, f'Unrecognised command: {command}'
 
-        log2(f'Finished handling command: {command}')
+        _log(f'handle_argv(): Finished handling command={command}')
 
 
     def __str__(self):
         return ('{'
             f'name={self.name!r}'
             f' version={self.version!r}'
-            f' platform={self.platform!r}'
-            f' supported_platform={self.supported_platform!r}'
+            f' root_sep={self.root_sep!r}'
             f' summary={self.summary!r}'
             f' description={self.description!r}'
-            f' description_content_type={self.description_content_type!r}'
-            f' keywords={self.keywords!r}'
-            f' home_page={self.home_page!r}'
-            f' download_url={self.download_url!r}'
+            f' classifiers={self.classifiers!r}'
             f' author={self.author!r}'
-            f' author_email={self.author_email!r}'
-            f' maintainer={self.maintainer!r}'
-            f' maintainer_email={self.maintainer_email!r}'
+            f' author_email ={self.author_email!r}'
+            f' url_docs={self.url_docs!r}'
+            f' url_home ={self.url_home!r}'
+            f' url_source={self.url_source!r}'
+            f' url_tracker={self.url_tracker!r}'
+            f' url_changelog={self.url_changelog!r}'
+            f' keywords={self.keywords!r}'
+            f' platform={self.platform!r}'
             f' license={self.license!r}'
-            f' classifier={self.classifier!r}'
-            f' requires_dist={self.requires_dist!r}'
-            f' requires_python={self.requires_python!r}'
-            f' requires_external={self.requires_external!r}'
-            f' project_url={self.project_url!r}'
-            f' provides_extra={self.provides_extra!r}'
-
-            f' root={self.root!r}'
+            f' license_files={self.license_files!r}'
             f' fn_build={self.fn_build!r}'
             f' fn_sdist={self.fn_sdist!r}'
             f' fn_clean={self.fn_clean!r}'
-            f' tag_python={self.tag_python!r}'
-            f' tag_abi={self.tag_abi!r}'
-            f' tag_platform={self.tag_platform!r}'
             '}'
             )
 
-    def _dist_info_dir( self):
-        return f'{self.name}-{self.version}.dist-info'
 
     def _metainfo(self):
         '''
@@ -1083,53 +581,31 @@ class Package:
         #
         ret = ['']
         def add(key, value):
-            if value is None:
-                return
-            if isinstance( value, (tuple, list)):
-                for v in value:
-                    add( key, v)
-                return
-            if key == 'License' and '\n' in value:
-                # This is ok because we write `self.license` into
-                # *.dist-info/COPYING.
-                #
-                log1( f'Omitting license because contains newline(s).')
-                return
-            assert '\n' not in value, f'key={key} value contains newline: {value!r}'
-            if key == 'Project-URL':
-                assert value.count(',') == 1, f'For {key=}, should have one comma in {value!r}.'
-            ret[0] += f'{key}: {value}\n'
+            if value is not None:
+                assert '\n' not in value, f'key={key} value contains newline: {value!r}'
+                ret[0] += f'{key}: {value}\n'
+        add('Metadata-Version', '1.2')
+        add('Name', self.name)
+        add('Version', self.version)
+        add('Summary', self.summary)
         #add('Description', self.description)
-        add('Metadata-Version', '2.1')
-
-        # These names are from:
-        # https://packaging.python.org/specifications/core-metadata/
-        #
-        for name in (
-                'Name',
-                'Version',
-                'Platform',
-                'Supported-Platform',
-                'Summary',
-                'Description-Content-Type',
-                'Keywords',
-                'Home-page',
-                'Download-URL',
-                'Author',
-                'Author-email',
-                'Maintainer',
-                'Maintainer-email',
-                'License',
-                'Classifier',
-                'Requires-Dist',
-                'Requires-Python',
-                'Requires-External',
-                'Project-URL',
-                'Provides-Extra',
-                ):
-            identifier = name.lower().replace( '-', '_')
-            add( name, getattr( self, identifier))
-
+        add('Home-page', self.url_home)
+        add('Platform', self.platform)
+        add('Author', self.author)
+        add('Author-email', self.author_email)
+        if self.license:        add('License', self.license)
+        if self.url_source:     add('Home-page', f'Source, {self.url_source}')
+        if self.url_docs:       add('Home-page', f'Source, {self.url_docs}')
+        if self.url_tracker:    add('Home-page', f'Source, {self.url_tracker}')
+        if self.url_changelog:  add('Home-page', f'Source, {self.url_changelog}')
+        if self.keywords:
+            add('Keywords', self.keywords)
+        if self.classifiers:
+            classifiers2 = self.classifiers
+            if isinstance(classifiers2, str):
+                classifiers2 = classifiers2.split('\n')
+            for c in classifiers2:
+                add('Classifier', c)
         ret = ret[0]
 
         # Append description as the body
@@ -1139,49 +615,39 @@ class Package:
             ret += '\n'
         return ret
 
-    def _path_relative_to_root(self, path, assert_within_root=True):
+    def _path_relative_to_root(self, path):
         '''
         Returns `(path_abs, path_rel)`, where `path_abs` is absolute path and
-        `path_rel` is relative to `self.root`.
+        `path_rel` is relative to `self.root_sep`.
 
-        Interprets `path` as relative to `self.root` if not absolute.
+        Interprets `path` as relative to `self.root_sep` if not absolute.
 
         We use `os.path.realpath()` to resolve any links.
 
-        if `assert_within_root` is true, assert-fails if `path` is not within
-        `self.root`.
+        Assert-fails if `path` is not within `self.root_sep`.
         '''
         if os.path.isabs(path):
             p = path
         else:
-            p = os.path.join(self.root, path)
+            p = os.path.join(self.root_sep, path)
         p = os.path.realpath(os.path.abspath(p))
-        if assert_within_root:
-            assert p.startswith(self.root+os.sep) or p == self.root, \
-                    f'Path not within root={self.root+os.sep!r}: {path=} {p=}'
-        p_rel = os.path.relpath(p, self.root)
+        assert p.startswith(self.root_sep), f'Path not within root={self.root_sep}: {path}'
+        p_rel = os.path.relpath(p, self.root_sep)
         return p, p_rel
 
     def _fromto(self, p):
         '''
         Returns `((from_abs, from_rel), (to_abs, to_rel))`.
 
-        If `p` is a string we convert to `(p, p)`. Otherwise we assert
-        that `p` is a tuple of two string, `(from_, to_)`. Non-absolute
-        paths are assumed to be relative to `self.root`. If `to_` is
-        empty or ends with `/`, we append the leaf of `from_`.
-
-        If `to_` starts with `$dist-info/`, we replace this with
-        `self._dist_info_dir()`.
-
-        If `to_` starts with `$data/`, we replace this with
-        `{self.name}-{self.version}.data/`.
+        If `p` is a string we convert to `(p, p)`. Otherwise we assert that
+        `p` is a tuple of two strings. Non-absolute paths are assumed to be
+        relative to `self.root_sep`.
 
-        `from_abs` and `to_abs` are absolute paths. We assert that `to_abs` is
-        `within self.root`.
+        `from_abs` and `to_abs` are absolute paths, asserted to be within
+        `self.root_sep`.
 
         `from_rel` and `to_rel` are derived from the `_abs` paths and are
-        `relative to self.root`.
+        `relative to self.root_sep`.
         '''
         ret = None
         if isinstance(p, str):
@@ -1192,485 +658,26 @@ class Package:
                 ret = from_, to_
         assert ret, 'p should be str or (str, str), but is: {p}'
         from_, to_ = ret
-        if to_.endswith('/') or to_=='':
-            to_ += os.path.basename(from_)
-        prefix = '$dist-info/'
-        if to_.startswith( prefix):
-            to_ = f'{self._dist_info_dir()}/{to_[ len(prefix):]}'
-        prefix = '$data/'
-        if to_.startswith( prefix):
-            to_ = f'{self.name}-{self.version}.data/{to_[ len(prefix):]}'
-        from_ = self._path_relative_to_root( from_, assert_within_root=False)
-        to_ = self._path_relative_to_root(to_)
-        return from_, to_
-
-
-def build_extension(
-        name,
-        path_i,
-        outdir,
-        builddir=None,
-        includes=None,
-        defines=None,
-        libpaths=None,
-        libs=None,
-        optimise=True,
-        debug=False,
-        compiler_extra='',
-        linker_extra='',
-        swig='swig',
-        cpp=True,
-        prerequisites_swig=None,
-        prerequisites_compile=None,
-        prerequisites_link=None,
-        infer_swig_includes=True,
-        ):
-    '''
-    Builds a Python extension module using SWIG. Works on Windows, Linux, MacOS
-    and OpenBSD.
-
-    On Unix, sets rpath when linking shared libraries.
-
-    Args:
-        name:
-            Name of generated extension module.
-        path_i:
-            Path of input SWIG `.i` file. Internally we use swig to generate a
-            corresponding `.c` or `.cpp` file.
-        outdir:
-            Output directory for generated files:
-
-                * `{outdir}/{name}.py`
-                * `{outdir}/_{name}.so`     # Unix
-                * `{outdir}/_{name}.*.pyd`  # Windows
-            We return the leafname of the `.so` or `.pyd` file.
-        builddir:
-            Where to put intermediate files, for example the .cpp file
-            generated by swig and `.d` dependency files. Default is `outdir`.
-        includes:
-            A string, or a sequence of extra include directories to be prefixed
-            with `-I`.
-        defines:
-            A string, or a sequence of extra preprocessor defines to be
-            prefixed with `-D`.
-        libpaths
-            A string, or a sequence of library paths to be prefixed with
-            `/LIBPATH:` on Windows or `-L` on Unix.
-        libs
-            A string, or a sequence of library names to be prefixed with `-l`.
-        optimise:
-            Whether to use compiler optimisations.
-        debug:
-            Whether to build with debug symbols.
-        compiler_extra:
-            Extra compiler flags.
-        linker_extra:
-            Extra linker flags.
-        swig:
-            Base swig command.
-        cpp:
-            If true we tell SWIG to generate C++ code instead of C.
-        prerequisites_swig:
-        prerequisites_compile:
-        prerequisites_link:
-
-            [These are mainly for use on Windows. On other systems we
-            automatically generate dynamic dependencies using swig/compile/link
-            commands' `-MD` and `-MF` args.]
-
-            Sequences of extra input files/directories that should force
-            running of swig, compile or link commands if they are newer than
-            any existing generated SWIG `.i` file, compiled object file or
-            shared library file.
-
-            If present, the first occurrence of `True` or `False` forces re-run
-            or no re-run. Any occurrence of None is ignored. If an item is a
-            directory path we look for newest file within the directory tree.
-
-            If not a sequence, we convert into a single-item list.
-
-            prerequisites_swig
-
-                We use swig's -MD and -MF args to generate dynamic dependencies
-                automatically, so this is not usually required.
-
-            prerequisites_compile
-            prerequisites_link
-
-                On non-Windows we use cc's -MF and -MF args to generate dynamic
-                dependencies so this is not usually required.
-        infer_swig_includes:
-            If true, we extract `-I<path>` and `-I <path>` args from
-            `compile_extra` (also `/I` on windows) and use them with swig so
-            that it can see the same header files as C/C++. This is useful
-            when using enviromment variables such as `CC` and `CXX` to set
-            `compile_extra.
-
-    Returns the leafname of the generated library file within `outdir`, e.g.
-    `_{name}.so` on Unix or `_{name}.cp311-win_amd64.pyd` on Windows.
-    '''
-    if builddir is None:
-        builddir = outdir
-    includes_text = _flags( includes, '-I')
-    defines_text = _flags( defines, '-D')
-    libpaths_text = _flags( libpaths, '/LIBPATH:', '"') if windows() else _flags( libpaths, '-L')
-    libs_text = _flags( libs, '-l')
-    path_cpp = f'{builddir}/{os.path.basename(path_i)}'
-    path_cpp += '.cpp' if cpp else '.c'
-    os.makedirs( outdir, exist_ok=True)
-
-    # Run SWIG.
-
-    if infer_swig_includes:
-        # Extract include flags from `compiler_extra`.
-        swig_includes_extra = ''
-        compiler_extra_items = compiler_extra.split()
-        i = 0
-        while i < len(compiler_extra_items):
-            item = compiler_extra_items[i]
-            # Swig doesn't seem to like a space after `I`.
-            if item == '-I' or (windows() and item == '/I'):
-                swig_includes_extra += f' -I{compiler_extra_items[i+1]}'
-                i += 1
-            elif item.startswith('-I') or (windows() and item.startswith('/I')):
-                swig_includes_extra += f' -I{compiler_extra_items[i][2:]}'
-            i += 1
-        swig_includes_extra = swig_includes_extra.strip()
-    deps_path = f'{path_cpp}.d'
-    prerequisites_swig2 = _get_prerequisites( deps_path)
-    run_if(
-            f'''
-            {swig}
-                -Wall
-                {"-c++" if cpp else ""}
-                -python
-                -module {name}
-                -outdir {outdir}
-                -o {path_cpp}
-                -MD -MF {deps_path}
-                {includes_text}
-                {swig_includes_extra}
-                {path_i}
-            '''
-            ,
-            path_cpp,
-            path_i,
-            prerequisites_swig,
-            prerequisites_swig2,
-            )
-
-    path_so_leaf = f'_{name}{_so_suffix()}'
-    path_so = f'{outdir}/{path_so_leaf}'
-
-    if windows():
-        path_obj        = f'{path_so}.obj'
-
-        permissive = '/permissive-'
-        EHsc = '/EHsc'
-        T = '/Tp' if cpp else '/Tc'
-        optimise2 = '/DNDEBUG /O2' if optimise else '/D_DEBUG'
-        debug2 = ''
-        if debug:
-            debug2 = '/Zi'  # Generate .pdb.
-            # debug2 = '/Z7'    # Embded debug info in .obj files.
-
-        # As of 2023-08-23, it looks like VS tools create slightly
-        # .dll's each time, even with identical inputs.
-        #
-        # Some info about this is at:
-        # https://nikhilism.com/post/2020/windows-deterministic-builds/.
-        # E.g. an undocumented linker flag `/Brepro`.
-        #
-
-        command, pythonflags = base_compiler(cpp=cpp)
-        command = f'''
-                {command}
-                    # General:
-                    /c                          # Compiles without linking.
-                    {EHsc}                      # Enable "Standard C++ exception handling".
-
-                    #/MD                         # Creates a multithreaded DLL using MSVCRT.lib.
-                    {'/MDd' if debug else '/MD'}
-
-                    # Input/output files:
-                    {T}{path_cpp}               # /Tp specifies C++ source file.
-                    /Fo{path_obj}               # Output file.
-
-                    # Include paths:
-                    {includes_text}
-                    {pythonflags.includes}      # Include path for Python headers.
-
-                    # Code generation:
-                    {optimise2}
-                    {debug2}
-                    {permissive}                # Set standard-conformance mode.
-
-                    # Diagnostics:
-                    #/FC                         # Display full path of source code files passed to cl.exe in diagnostic text.
-                    /W3                         # Sets which warning level to output. /W3 is IDE default.
-                    /diagnostics:caret          # Controls the format of diagnostic messages.
-                    /nologo                     #
-
-                    {defines_text}
-                    {compiler_extra}
-                '''
-        run_if( command, path_obj, path_cpp, prerequisites_compile)
-
-        command, pythonflags = base_linker(cpp=cpp)
-        debug2 = '/DEBUG' if debug else ''
-        base, _ = os.path.splitext(path_so_leaf)
-        command = f'''
-                {command}
-                    /DLL                    # Builds a DLL.
-                    /EXPORT:PyInit__{name}  # Exports a function.
-                    /IMPLIB:{base}.lib      # Overrides the default import library name.
-                    {libpaths_text}
-                    {pythonflags.ldflags}
-                    /OUT:{path_so}          # Specifies the output file name.
-                    {debug2}
-                    /nologo
-                    {libs_text}
-                    {path_obj}
-                    {linker_extra}
-                '''
-        run_if( command, path_so, path_obj, prerequisites_link)
-
-    else:
-
-        # Not Windows.
-        #
-        command, pythonflags = base_compiler(cpp=cpp)
-
-        # setuptools on Linux seems to use slightly different compile flags:
-        #
-        # -fwrapv -O3 -Wall -O2 -g0 -DPY_CALL_TRAMPOLINE
-        #
-
-        general_flags = ''
-        if debug:
-            general_flags += ' -g'
-        if optimise:
-            general_flags += ' -O2 -DNDEBUG'
-
-        if darwin():
-            # MacOS's linker does not like `-z origin`.
-            rpath_flag = "-Wl,-rpath,@loader_path/"
-
-            # Avoid `Undefined symbols for ... "_PyArg_UnpackTuple" ...'.
-            general_flags += ' -undefined dynamic_lookup'
-        elif pyodide():
-            # Setting `-Wl,-rpath,'$ORIGIN',-z,origin` gives:
-            #   emcc: warning: ignoring unsupported linker flag: `-rpath` [-Wlinkflags]
-            #   wasm-ld: error: unknown -z value: origin
-            #
-            log0(f'## pyodide(): PEP-3149 suffix untested, so omitting. {_so_suffix()=}.')
-            path_so_leaf = f'_{name}.so'
-            path_so = f'{outdir}/{path_so_leaf}'
-
-            rpath_flag = ''
-        else:
-            rpath_flag = "-Wl,-rpath,'$ORIGIN',-z,origin"
-        path_so = f'{outdir}/{path_so_leaf}'
-        # Fun fact - on Linux, if the -L and -l options are before '{path_cpp}'
-        # they seem to be ignored...
-        #
-        prerequisites = list()
-
-        if pyodide():
-            # Looks like pyodide's `cc` can't compile and link in one invocation.
-            prerequisites_compile_path = f'{path_cpp}.o.d'
-            prerequisites += _get_prerequisites( prerequisites_compile_path)
-            command = f'''
-                    {command}
-                        -fPIC
-                        {general_flags.strip()}
-                        {pythonflags.includes}
-                        {includes_text}
-                        {defines_text}
-                        -MD -MF {prerequisites_compile_path}
-                        -c {path_cpp}
-                        -o {path_cpp}.o
-                        {compiler_extra}
-                    '''
-            prerequisites_link_path = f'{path_cpp}.o.d'
-            prerequisites += _get_prerequisites( prerequisites_link_path)
-            ld, _ = base_linker(cpp=cpp)
-            command += f'''
-                    && {ld}
-                        {path_cpp}.o
-                        -o {path_so}
-                        -MD -MF {prerequisites_link_path}
-                        {rpath_flag}
-                        {libpaths_text}
-                        {libs_text}
-                        {linker_extra}
-                        {pythonflags.ldflags}
-                    '''
-        else:
-            # We use compiler to compile and link in one command.
-            prerequisites_path = f'{path_so}.d'
-            prerequisites = _get_prerequisites(prerequisites_path)
-
-            command = f'''
-                    {command}
-                        -fPIC
-                        -shared
-                        {general_flags.strip()}
-                        {pythonflags.includes}
-                        {includes_text}
-                        {defines_text}
-                        {path_cpp}
-                        -MD -MF {prerequisites_path}
-                        -o {path_so}
-                        {compiler_extra}
-                        {libpaths_text}
-                        {linker_extra}
-                        {pythonflags.ldflags}
-                        {libs_text}
-                        {rpath_flag}
-                    '''
-        run_if(
-                command,
-                path_so,
-                path_cpp,
-                prerequisites_compile,
-                prerequisites_link,
-                prerequisites,
-                )
-
-        if darwin():
-            # We need to patch up references to shared libraries in `libs`.
-            sublibraries = list()
-            for lib in libs:
-                for libpath in libpaths:
-                    found = list()
-                    for suffix in '.so', '.dylib':
-                        path = f'{libpath}/lib{os.path.basename(lib)}{suffix}'
-                        if os.path.exists( path):
-                            found.append( path)
-                    if found:
-                        assert len(found) == 1, f'More than one file matches lib={lib!r}: {found}'
-                        sublibraries.append( found[0])
-                        break
-                else:
-                    log2(f'Warning: can not find path of lib={lib!r} in libpaths={libpaths}')
-            macos_patch( path_so, *sublibraries)
-
-        #run(f'ls -l {path_so}', check=0)
-        #run(f'file {path_so}', check=0)
-
-    return path_so_leaf
+        return self._path_relative_to_root(from_), self._path_relative_to_root(to_)
 
 
 # Functions that might be useful.
 #
 
-
-def base_compiler(vs=None, pythonflags=None, cpp=False, use_env=True):
-    '''
-    Returns basic compiler command and PythonFlags.
-
-    Args:
-        vs:
-            Windows only. A `wdev.WindowsVS` instance or None to use default
-            `wdev.WindowsVS` instance.
-        pythonflags:
-            A `pipcl.PythonFlags` instance or None to use default
-            `pipcl.PythonFlags` instance.
-        cpp:
-            If true we return C++ compiler command instead of C. On Windows
-            this has no effect - we always return `cl.exe`.
-        use_env:
-            If true we use `os.environ['CC']` or `os.environ['CXX']` if set.
-
-    Returns `(cc, pythonflags)`:
-        cc:
-            C or C++ command. On Windows this is of the form
-            `{vs.vcvars}&&{vs.cl}`; otherwise it is typically `cc` or `c++`.
-        pythonflags:
-            The `pythonflags` arg or a new `pipcl.PythonFlags` instance.
-    '''
-    if not pythonflags:
-        pythonflags = PythonFlags()
-    cc = os.environ.get( 'CXX' if cpp else 'CC') if use_env else None
-    if cc:
-        pass
-    elif windows():
-        if not vs:
-            vs = wdev.WindowsVS()
-        cc = f'"{vs.vcvars}"&&"{vs.cl}"'
-    elif wasm():
-        cc = 'em++' if cpp else 'emcc'
-    else:
-        cc = 'c++' if cpp else 'cc'
-    cc = macos_add_cross_flags( cc)
-    return cc, pythonflags
-
-
-def base_linker(vs=None, pythonflags=None, cpp=False, use_env=True):
-    '''
-    Returns basic linker command.
-
-    Args:
-        vs:
-            Windows only. A `wdev.WindowsVS` instance or None to use default
-            `wdev.WindowsVS` instance.
-        pythonflags:
-            A `pipcl.PythonFlags` instance or None to use default
-            `pipcl.PythonFlags` instance.
-        cpp:
-            If true we return C++ linker command instead of C. On Windows this
-            has no effect - we always return `link.exe`.
-        use_env:
-            If true we use `os.environ['LD']` if set.
-
-    Returns `(linker, pythonflags)`:
-        linker:
-            Linker command. On Windows this is of the form
-            `{vs.vcvars}&&{vs.link}`; otherwise it is typically `cc` or `c++`.
-        pythonflags:
-            The `pythonflags` arg or a new `pipcl.PythonFlags` instance.
-    '''
-    if not pythonflags:
-        pythonflags = PythonFlags()
-    linker = os.environ.get( 'LD') if use_env else None
-    if linker:
-        pass
-    elif windows():
-        if not vs:
-            vs = wdev.WindowsVS()
-        linker = f'"{vs.vcvars}"&&"{vs.link}"'
-    elif wasm():
-        linker = 'em++' if cpp else 'emcc'
-    else:
-        linker = 'c++' if cpp else 'cc'
-    linker = macos_add_cross_flags( linker)
-    return linker, pythonflags
-
-
 def git_items( directory, submodules=False):
     '''
-    Returns list of paths for all files known to git within a `directory`.
-
-    Args:
-        directory:
-            Must be somewhere within a git checkout.
-        submodules:
-            If true we also include git submodules.
+    Helper for `pipcl.Package`'s `fn_sdist()` callback.
 
-    Returns:
-        A list of paths for all files known to git within `directory`. Each
-        path is relative to `directory`. `directory` must be somewhere within a
-        git checkout.
+    Returns list of paths for all files known to git within `directory`. Each
+    path is relative to `directory`.
 
-    We run a `git ls-files` command internally.
+    `directory` must be somewhere within a git checkout.
 
-    This function can be useful for the `fn_sdist()` callback.
+    We run a 'git ls-files' command internally.
     '''
     command = 'cd ' + directory + ' && git ls-files'
     if submodules:
         command += ' --recurse-submodules'
-    log1(f'Running {command=}')
     text = subprocess.check_output( command, shell=True)
     ret = []
     for path in text.decode('utf8').strip().split( '\n'):
@@ -1679,504 +686,39 @@ def git_items( directory, submodules=False):
         # within submodules.
         #
         if not os.path.exists(path2):
-            log2(f'Ignoring git ls-files item that does not exist: {path2}')
+            _log(f'*** Ignoring git ls-files item that does not exist: {path2}')
         elif os.path.isdir(path2):
-            log2(f'Ignoring git ls-files item that is actually a directory: {path2}')
+            _log(f'*** Ignoring git ls-files item that is actually a directory: {path2}')
         else:
             ret.append(path)
     return ret
 
 
-def run( command, capture=False, check=1):
-    '''
-    Runs a command using `subprocess.run()`.
-
-    Args:
-        command:
-            A string, the command to run.
-
-            Multiple lines in `command` are are treated as a single command.
-
-            * If a line starts with `#` it is discarded.
-            * If a line contains ` #`, the trailing text is discarded.
-
-            When running the command, on Windows newlines are replaced by
-            spaces; otherwise each line is terminated by a backslash character.
-        capture:
-            If true, we return output from command.
-    Returns:
-        None on success, otherwise raises an exception.
+def parse_pkg_info(path):
     '''
-    lines = _command_lines( command)
-    nl = '\n'
-    log2( f'Running: {nl.join(lines)}')
-    sep = ' ' if windows() else '\\\n'
-    command2 = sep.join( lines)
-    if capture:
-        return subprocess.run(
-                command2,
-                shell=True,
-                capture_output=True,
-                check=check,
-                encoding='utf8',
-                ).stdout
-    else:
-        subprocess.run( command2, shell=True, check=check)
-
-
-def darwin():
-    return sys.platform.startswith( 'darwin')
-
-def windows():
-    return platform.system() == 'Windows'
-
-def wasm():
-    return os.environ.get( 'OS') in ('wasm', 'wasm-mt')
-
-def pyodide():
-    return os.environ.get( 'PYODIDE') == '1'
-
-def linux():
-    return platform.system() == 'Linux'
-
-class PythonFlags:
+    Parses a `PKJG-INFO` file, each line is `<key>: <value>\n`. Returns a dict.
     '''
-    Compile/link flags for the current python, for example the include path
-    needed to get `Python.h`.
-
-    Members:
-        .includes:
-            String containing compiler flags for include paths.
-        .ldflags:
-            String containing linker flags for library paths.
-    '''
-    def __init__(self):
-
-        if windows():
-            wp = wdev.WindowsPython()
-            self.includes = f'/I"{wp.root}\\include"'
-            self.ldflags = f'/LIBPATH:"{wp.root}\\libs"'
-
-        elif pyodide():
-            _include_dir = os.environ[ 'PYO3_CROSS_INCLUDE_DIR']
-            _lib_dir = os.environ[ 'PYO3_CROSS_LIB_DIR']
-            self.includes = f'-I {_include_dir}'
-            self.ldflags = f'-L {_lib_dir}'
-            log2(f'PythonFlags: Pyodide.')
-            log2( f'    {_include_dir=}')
-            log2( f'    {_lib_dir=}')
-
-        else:
-            # We use python-config which appears to work better than pkg-config
-            # because it copes with multiple installed python's, e.g.
-            # manylinux_2014's /opt/python/cp*-cp*/bin/python*.
-            #
-            # But... on non-macos it seems that we should not attempt to specify
-            # libpython on the link command. The manylinux docker containers
-            # don't actually contain libpython.so, and it seems that this
-            # deliberate. And the link command runs ok.
-            #
-            python_exe = os.path.realpath( sys.executable)
-            if darwin():
-                # Basic install of dev tools with `xcode-select --install` doesn't
-                # seem to provide a `python3-config` or similar, but there is a
-                # `python-config.py` accessible via sysconfig.
-                #
-                # We try different possibilities and use the last one that
-                # works.
-                #
-                python_config = None
-                for pc in (
-                        f'python3-config',
-                        f'{sys.executable} {sysconfig.get_config_var("srcdir")}/python-config.py',
-                        f'{python_exe}-config',
-                        ):
-                    e = subprocess.run(
-                            f'{pc} --includes',
-                            shell=1,
-                            stdout=subprocess.DEVNULL,
-                            stderr=subprocess.DEVNULL,
-                            check=0,
-                            ).returncode
-                    log1(f'{e=} from {pc!r}.')
-                    if e == 0:
-                        python_config = pc
-                assert python_config, f'Cannot find python-config'
-            else:
-                python_config = f'{python_exe}-config'
-            log1(f'Using {python_config=}.')
-            self.includes = run( f'{python_config} --includes', capture=1).strip()
-            #if darwin():
-            #    self.ldflags =
-            self.ldflags = run( f'{python_config} --ldflags', capture=1).strip()
-            if linux():
-                # It seems that with python-3.10 on Linux, we can get an
-                # incorrect -lcrypt flag that on some systems (e.g. WSL)
-                # causes:
-                #
-                #   ImportError: libcrypt.so.2: cannot open shared object file: No such file or directory
-                #
-                ldflags2 = self.ldflags.replace(' -lcrypt ', ' ')
-                if ldflags2 != self.ldflags:
-                    log2(f'### Have removed `-lcrypt` from ldflags: {self.ldflags!r} -> {ldflags2!r}')
-                    self.ldflags = ldflags2
-
-        log2(f'{self.includes=}')
-        log2(f'{self.ldflags=}')
-
-
-def macos_add_cross_flags(command):
-    '''
-    If running on MacOS and environment variables ARCHFLAGS is set
-    (indicating we are cross-building, e.g. for arm64), returns
-    `command` with extra flags appended. Otherwise returns unchanged
-    `command`.
-    '''
-    if darwin():
-        archflags = os.environ.get( 'ARCHFLAGS')
-        if archflags:
-            command = f'{command} {archflags}'
-            log2(f'Appending ARCHFLAGS to command: {command}')
-            return command
-    return command
-
-
-def macos_patch( library, *sublibraries):
-    '''
-    If running on MacOS, patches `library` so that all references to items in
-    `sublibraries` are changed to `@rpath/{leafname}`. Does nothing on other
-    platforms.
-
-    library:
-        Path of shared library.
-    sublibraries:
-        List of paths of shared libraries; these have typically been
-        specified with `-l` when `library` was created.
-    '''
-    log2( f'macos_patch(): library={library}  sublibraries={sublibraries}')
-    if not darwin():
-        return
-    subprocess.run( f'otool -L {library}', shell=1, check=1)
-    command = 'install_name_tool'
-    names = []
-    for sublibrary in sublibraries:
-        name = subprocess.run(
-                f'otool -D {sublibrary}',
-                shell=1,
-                check=1,
-                capture_output=1,
-                encoding='utf8',
-                ).stdout.strip()
-        name = name.split('\n')
-        assert len(name) == 2 and name[0] == f'{sublibrary}:', f'{name=}'
-        name = name[1]
-        # strip trailing so_name.
-        leaf = os.path.basename(name)
-        m = re.match('^(.+[.]((so)|(dylib)))[0-9.]*$', leaf)
-        assert m
-        log2(f'Changing {leaf=} to {m.group(1)}')
-        leaf = m.group(1)
-        command += f' -change {name} @rpath/{leaf}'
-    command += f' {library}'
-    log2( f'Running: {command}')
-    subprocess.run( command, shell=1, check=1)
-    subprocess.run( f'otool -L {library}', shell=1, check=1)
-
-
-# Internal helpers.
-#
-
-def _command_lines( command):
-    '''
-    Process multiline command by running through `textwrap.dedent()`, removes
-    comments (lines starting with `#` or ` #` until end of line), removes
-    entirely blank lines.
-
-    Returns list of lines.
-    '''
-    command = textwrap.dedent( command)
-    lines = []
-    for line in command.split( '\n'):
-        if line.startswith( '#'):
-            h = 0
-        else:
-            h = line.find( ' #')
-        if h >= 0:
-            line = line[:h]
-        if line.strip():
-            lines.append(line.rstrip())
-    return lines
-
-
-def _cpu_name():
-    '''
-    Returns `x32` or `x64` depending on Python build.
-    '''
-    #log(f'sys.maxsize={hex(sys.maxsize)}')
-    return f'x{32 if sys.maxsize == 2**31 - 1 else 64}'
-
-
-def run_if( command, out, *prerequisites):
-    '''
-    Runs a command only if the output file is not up to date.
-
-    Args:
-        command:
-            The command to run. We write this into a file <out>.cmd so that we
-            know to run a command if the command itself has changed.
-        out:
-            Path of the output file.
-
-        prerequisites:
-            List of prerequisite paths or true/false/None items. If an item
-            is None it is ignored, otherwise if an item is not a string we
-            immediately return it cast to a bool.
-
-    Returns:
-        True if we ran the command, otherwise None.
-
-
-    If the output file does not exist, the command is run:
-
-        >>> verbose(1)
-        1
-        >>> out = 'run_if_test_out'
-        >>> if os.path.exists( out):
-        ...     os.remove( out)
-        >>> run_if( f'touch {out}', out)
-        True
-
-    If we repeat, the output file will be up to date so the command is not run:
-
-        >>> run_if( f'touch {out}', out)
-
-    If we change the command, the command is run:
-
-        >>> run_if( f'touch  {out}', out)
-        True
-
-    If we add a prerequisite that is newer than the output, the command is run:
-
-        >>> prerequisite = 'run_if_test_prerequisite'
-        >>> run( f'touch {prerequisite}')
-        >>> run_if( f'touch {out}', out, prerequisite)
-        True
-
-    If we repeat, the output will be newer than the prerequisite, so the
-    command is not run:
-
-        >>> run_if( f'touch {out}', out, prerequisite)
-    '''
-    doit = False
-    if not doit:
-        out_mtime = _fs_mtime( out)
-        if out_mtime == 0:
-            doit = 'File does not exist: {out!e}'
-
-    cmd_path = f'{out}.cmd'
-    if os.path.isfile( cmd_path):
-        with open( cmd_path) as f:
-            cmd = f.read()
-    else:
-        cmd = None
-    if command != cmd:
-        if cmd is None:
-            doit = 'No previous command stored'
-        else:
-            doit = f'Command has changed'
-            if 0:
-                doit += f': {cmd!r} => {command!r}'
-
-    if not doit:
-        # See whether any prerequisites are newer than target.
-        def _make_prerequisites(p):
-            if isinstance( p, (list, tuple)):
-                return list(p)
-            else:
-                return [p]
-        prerequisites_all = list()
-        for p in prerequisites:
-            prerequisites_all += _make_prerequisites( p)
-        if 0:
-            log2( 'prerequisites_all:')
-            for i in  prerequisites_all:
-                log2( f'    {i!r}')
-        pre_mtime = 0
-        pre_path = None
-        for prerequisite in prerequisites_all:
-            if isinstance( prerequisite, str):
-                mtime = _fs_mtime_newest( prerequisite)
-                if mtime >= pre_mtime:
-                    pre_mtime = mtime
-                    pre_path = prerequisite
-            elif prerequisite is None:
-                pass
-            elif prerequisite:
-                doit = str(prerequisite)
-                break
-        if not doit:
-            if pre_mtime > out_mtime:
-                doit = f'Prerequisite is new: {pre_path!r}'
-
-    if doit:
-        # Remove `cmd_path` before we run the command, so any failure
-        # will force rerun next time.
-        #
-        try:
-            os.remove( cmd_path)
-        except Exception:
-            pass
-        log2( f'Running command because: {doit}')
-
-        run( command)
-
-        # Write the command we ran, into `cmd_path`.
-        with open( cmd_path, 'w') as f:
-            f.write( command)
-        return True
-    else:
-        log2( f'Not running command because up to date: {out!r}')
-
-    if 0:
-        log2( f'out_mtime={time.ctime(out_mtime)} pre_mtime={time.ctime(pre_mtime)}.'
-                f' pre_path={pre_path!r}: returning {ret!r}.'
-                )
-
-
-def _get_prerequisites(path):
-    '''
-    Returns list of prerequisites from Makefile-style dependency file, e.g.
-    created by `cc -MD -MF <path>`.
-    '''
-    ret = list()
-    if os.path.isfile(path):
-        with open(path) as f:
-            for line in f:
-                for item in line.split():
-                    if item.endswith( (':', '\\')):
-                        continue
-                    ret.append( item)
-    return ret
-
-
-def _fs_mtime_newest( path):
-    '''
-    path:
-        If a file, returns mtime of the file. If a directory, returns mtime of
-        newest file anywhere within directory tree. Otherwise returns 0.
-    '''
-    ret = 0
-    if os.path.isdir( path):
-        for dirpath, dirnames, filenames in os.walk( path):
-            for filename in filenames:
-                path = os.path.join( dirpath, filename)
-                ret = max( ret, _fs_mtime( path))
-    else:
-        ret = _fs_mtime( path)
+    ret = dict()
+    with open(path) as f:
+        for line in f:
+            s = line.find(': ')
+            if s >= 0 and line.endswith('\n'):
+                k = line[:s]
+                v = line[s+2:-1]
+                ret[k] = v
     return ret
 
 
-def _flags( items, prefix='', quote=''):
-    '''
-    Turns sequence into string, prefixing/quoting each item.
-    '''
-    if not items:
-        return ''
-    if isinstance( items, str):
-        return items
-    ret = ''
-    for item in items:
-        if ret:
-            ret += ' '
-        ret += f'{prefix}{quote}{item}{quote}'
-    return ret.strip()
-
-
-def _fs_mtime( filename, default=0):
-    '''
-    Returns mtime of file, or `default` if error - e.g. doesn't exist.
-    '''
-    try:
-        return os.path.getmtime( filename)
-    except OSError:
-        return default
-
-g_verbose = int(os.environ.get('PIPCL_VERBOSE', '2'))
-
-def verbose(level=None):
-    '''
-    Sets verbose level if `level` is not None.
-    Returns verbose level.
-    '''
-    global g_verbose
-    if level is not None:
-        g_verbose = level
-    return g_verbose
-
-def log0(text=''):
-    _log(text, 0)
-
-def log1(text=''):
-    _log(text, 1)
-
-def log2(text=''):
-    _log(text, 2)
+# Implementation helpers.
+#
 
-def _log(text, level):
+def _log(text=''):
     '''
     Logs lines with prefix.
     '''
-    if g_verbose >= level:
-        caller = inspect.stack()[2].function
-        for line in text.split('\n'):
-            print(f'pipcl.py: {caller}(): {line}')
-        sys.stdout.flush()
-
-
-def _so_suffix():
-    '''
-    Filename suffix for shared libraries is defined in pep-3149.  The
-    pep claims to only address posix systems, but the recommended
-    sysconfig.get_config_var('EXT_SUFFIX') also seems to give the
-    right string on Windows.
-    '''
-    # Example values:
-    #   linux:      .cpython-311-x86_64-linux-gnu.so
-    #   macos:      .cpython-311-darwin.so
-    #   openbsd:    .cpython-310.so
-    #   windows     .cp311-win_amd64.pyd
-    #
-    # Only Linux and Windows seem to identify the cpu. For example shared
-    # libraries in numpy-1.25.2-cp311-cp311-macosx_11_0_arm64.whl are called
-    # things like `numpy/core/_simd.cpython-311-darwin.so`.
-    #
-    return sysconfig.get_config_var('EXT_SUFFIX')
-
-
-def install_dir(root=None):
-    '''
-    Returns install directory used by `install()`.
-
-    This will be `sysconfig.get_path('platlib')`, modified by `root` if not
-    None.
-    '''
-    # todo: for pure-python we should use sysconfig.get_path('purelib') ?
-    root2 = sysconfig.get_path('platlib')
-    if root:
-        if windows():
-            # If we are in a venv, `sysconfig.get_path('platlib')`
-            # can be absolute, e.g.
-            # `C:\\...\\venv-pypackage-3.11.1-64\\Lib\\site-packages`, so it's
-            # not clear how to append it to `root`. So we just use `root`.
-            return root
-        else:
-            # E.g. if `root` is `install' and `sysconfig.get_path('platlib')`
-            # is `/usr/local/lib/python3.9/site-packages`, we set `root2` to
-            # `install/usr/local/lib/python3.9/site-packages`.
-            #
-            return os.path.join( root, root2.lstrip( os.sep))
-    else:
-        return root2
+    for line in text.split('\n'):
+        print(f'pipcl.py: {line}')
+    sys.stdout.flush()
 
 
 class _Record:
@@ -2190,34 +732,15 @@ class _Record:
     def add_content(self, content, to_):
         if isinstance(content, str):
             content = content.encode('utf8')
-
-        # Specification for the line we write is supposed to be in
-        # https://packaging.python.org/en/latest/specifications/binary-distribution-format
-        # but it's not very clear.
-        #
         h = hashlib.sha256(content)
         digest = h.digest()
         digest = base64.urlsafe_b64encode(digest)
-        digest = digest.rstrip(b'=')
-        digest = digest.decode('utf8')
-
         self.text += f'{to_},sha256={digest},{len(content)}\n'
-        log2(f'Adding {to_}')
 
     def add_file(self, from_, to_):
         with open(from_, 'rb') as f:
             content = f.read()
         self.add_content(content, to_)
-        log2(f'Adding file: {os.path.relpath(from_)} => {to_}')
 
-    def get(self, record_path=None):
-        '''
-        Returns contents of the RECORD file. If `record_path` is
-        specified we append a final line `<record_path>,,`; this can be
-        used to include the RECORD file itself in the contents, with
-        empty hash and size fields.
-        '''
-        ret = self.text
-        if record_path:
-            ret += f'{record_path},,\n'
-        return ret
+    def get(self):
+        return self.text
diff --git a/jni/libmupdf/scripts/wdev.py b/jni/libmupdf/scripts/wdev.py
index b69c4c230..6f3a97415 100644
--- a/jni/libmupdf/scripts/wdev.py
+++ b/jni/libmupdf/scripts/wdev.py
@@ -34,8 +34,7 @@ class WindowsVS:
         '''
         Args:
             year:
-                None or, for example, `2019`. If None we use environment
-                variable WDEV_VS_YEAR if set.
+                None or, for example, `2019`.
             grade:
                 None or, for example, one of:
 
@@ -43,24 +42,11 @@ class WindowsVS:
                 * `Professional`
                 * `Enterprise`
 
-                If None we use environment variable WDEV_VS_GRADE if set.
             version:
-                None or, for example: `14.28.29910`. If None we use environment
-                variable WDEV_VS_VERSION if set.
+                None or, for example: `14.28.29910`
             cpu:
                 None or a `WindowsCpu` instance.
         '''
-        def default(value, name):
-            if value is None:
-                name2 = f'WDEV_VS_{name.upper()}'
-                value = os.environ.get(name2)
-                if value is not None:
-                    _log(f'Setting {name} from environment variable {name2}: {value!r}')
-            return value
-        year = default(year, 'year')
-        grade = default(grade, 'grade')
-        version = default(version, 'version')
-
         if not cpu:
             cpu = WindowsCpu()
 
@@ -140,6 +126,8 @@ class WindowsVS:
                     csc = os.path.join(dirpath, filename)
                     #_log(f'{csc=}')
                     #break
+            #if csc:
+            #    break
 
         self.cl = cl
         self.devenv = devenv
@@ -213,8 +201,8 @@ class WindowsCpu:
 
 class WindowsPython:
     '''
-    Windows only. Information about installed Python with specific word size
-    and version. Defaults to the currently-running Python.
+    Experimental. Windows only. Information about installed Python with
+    specific word size and version. Defaults to the currently-running Python.
 
     Members:
 
@@ -307,7 +295,7 @@ def _cpu_name():
     '''
     Returns `x32` or `x64` depending on Python build.
     '''
-    #log(f'sys.maxsize={hex(sys.maxsize)}')
+    _log(f'sys.maxsize={hex(sys.maxsize)}')
     return f'x{32 if sys.maxsize == 2**31 - 1 else 64}'
 
 
diff --git a/jni/libmupdf/scripts/wrap/__main__.py b/jni/libmupdf/scripts/wrap/__main__.py
index a543a689c..684d2e179 100644
--- a/jni/libmupdf/scripts/wrap/__main__.py
+++ b/jni/libmupdf/scripts/wrap/__main__.py
@@ -926,7 +926,6 @@ except ModuleNotFoundError:
     resource = None
 
 import jlib
-import pipcl
 import wdev
 
 from . import classes
@@ -1195,7 +1194,7 @@ def _get_m_command( build_dirs, j=None):
         make = 'CXX=clang++ gmake'
 
     if j is not None:
-        if j == 0:
+        if j == '0':
             j = multiprocessing.cpu_count()
             jlib.log('Setting -j to  multiprocessing.cpu_count()={j}')
         make += f' -j {j}'
@@ -1381,7 +1380,6 @@ def build_0(
             check_regress,
             clang_info_verbose,
             refcheck_if,
-            'debug' in build_dirs.dir_so,
             )
 
     generated.save(f'{build_dirs.dir_mupdf}/platform/c++')
@@ -1470,7 +1468,7 @@ def build( build_dirs, swig_command, args, vs_upgrade):
     clang_info_verbose = False
     force_rebuild = False
     header_git = False
-    j = 0
+    j = None
     refcheck_if = '#ifndef NDEBUG'
     wasm = os.environ.get('OS') in ('wasm', 'wasm-mt')
     if wasm:
@@ -1521,7 +1519,7 @@ def build( build_dirs, swig_command, args, vs_upgrade):
             if not state.state_.windows:
                 jlib.log( 'Warning: --devenv was specified, but we are not on Windows so this will have no effect.')
         elif actions == '-j':
-            j = int(args.next())
+            j = args.next()
         elif actions == '--python':
             build_python = True
             build_csharp = False
@@ -1892,9 +1890,23 @@ def build( build_dirs, swig_command, args, vs_upgrade):
                             flags_link = f'-L {_lib_dir}'
 
                         else:
-                            python_flags = pipcl.PythonFlags()
-                            flags_compile = python_flags.includes
-                            flags_link = python_flags.ldflags
+                            python_exe = os.path.realpath( sys.executable)
+                            jlib.log('python_exe={python_exe}')
+                            python_configs = (
+                                    f'{python_exe}-config',
+                                    'python3-config',
+                                    )
+                            jlib.log('python_configs={python_configs}')
+                            for python_config in python_configs:
+                                if jlib.fs_find_in_paths( python_config, verbose=True):
+                                    break
+                            else:
+                                raise Exception( f'Cannot find `python-config`, tried: {python_configs}')
+                            jlib.log( 'Using {python_config=}')
+                            # `--cflags` gives things like `-Wno-unused-result -g`
+                            # etc, -so we just use `--includes`.
+                            flags_compile = jlib.system( f'{python_config} --includes', out='return', verbose=1).replace('\n', ' ')
+                            flags_link = jlib.system( f'{python_config} --ldflags', out='return', verbose=1).replace('\n', ' ')
                         if state.state_.macos:
                             # We need this to avoid numerous errors like:
                             #
@@ -2580,16 +2592,41 @@ def main2():
                 jlib.system( f'rsync -aiRz {build_dirs.dir_mupdf}/docs/generated/./ {destination}', verbose=1, out='log')
 
             elif arg == '--test-cpp':
-                testfile = os.path.abspath( f'{__file__}/../../../thirdparty/zlib/zlib.3.pdf')
-                testfile = testfile.replace('\\', '/')
-                src = f'{build_dirs.dir_mupdf}/scripts/mupdfwrap_test.cpp'
-                exe = f'{build_dirs.dir_mupdf}/scripts/mupdfwrap_test.cpp.exe'
+                path = os.path.abspath( f'{__file__}/../../../thirdparty/zlib/zlib.3.pdf')
+                path = path.replace('\\', '/')
+                code = textwrap.dedent(f'''
+                        #include <assert.h>
+                        #include "mupdf/fitz.h"
+                        #include "mupdf/classes.h"
+                        #include "mupdf/classes2.h"
+                        int main()
+                        {{
+                            mupdf::FzDocument document("{path}");
+                            std::string v;
+                            v = mupdf::fz_lookup_metadata2(document, "format");
+                            printf("v=%s\\n", v.c_str());
+                            bool raised = false;
+                            try
+                            {{
+                                v = mupdf::fz_lookup_metadata2(document, "format___");
+                            }}
+                            catch (std::exception& e)
+                            {{
+                                raised = true;
+                                printf("exception: %s\\n", e.what());
+                            }}
+                            if (!raised) exit(1);
+                            printf("v=%s\\n", v.c_str());
+                            fz_rect r = fz_unit_rect;
+                            printf("r.x0=%f\\n", r.x0);
+                            return 0;
+                        }}
+                        ''')
+                jlib.fs_write( 'test.cpp', code)
                 includes = (
                         f' -I {build_dirs.dir_mupdf}/include'
                         f' -I {build_dirs.dir_mupdf}/platform/c++/include'
                         )
-                # Enable asserts in this test.
-                cpp_flags = build_dirs.cpp_flags.replace( '-DNDEBUG', '')
                 if state.state_.windows:
                     win32_infix = _windows_vs_upgrade( vs_upgrade, build_dirs, devenv=None)
                     windows_build_type = build_dirs.windows_build_type()
@@ -2597,18 +2634,18 @@ def main2():
                     vs = wdev.WindowsVS()
                     command = textwrap.dedent(f'''
                             "{vs.vcvars}"&&"{vs.cl}"
-                                /Tp{src}
+                                /Tptest.cpp
                                 {includes}
                                 -D FZ_DLL_CLIENT
-                                {cpp_flags}
+                                {build_dirs.cpp_flags}
                                 /link
                                 {lib}
-                                /out:{exe}
+                                /out:test.cpp.exe
                             ''').replace('\n', ' ')
                     jlib.system(command, verbose=1)
                     path = os.environ.get('PATH')
                     env_extra = dict(PATH = f'{build_dirs.dir_so}{os.pathsep}{path}' if path else build_dirs.dir_so)
-                    jlib.system(f'{exe} {testfile}', verbose=1, env_extra=env_extra)
+                    jlib.system('test.cpp.exe', verbose=1, env_extra=env_extra)
                 else:
                     dir_so_flags = os.path.basename( build_dirs.dir_so).split( '-')
                     if 'shared' in dir_so_flags:
@@ -2623,18 +2660,18 @@ def main2():
                         assert 0, f'Leaf must start with "shared-" or "fpic-": build_dirs.dir_so={build_dirs.dir_so}'
                     command = textwrap.dedent(f'''
                             c++
-                                -o {exe}
-                                {cpp_flags}
+                                -o test.cpp.exe
+                                {build_dirs.cpp_flags}
                                 {includes}
-                                {src}
+                                test.cpp
                                 {link_l_flags( [libmupdf, libmupdfcpp])}
                             ''').replace('\n', '\\\n')
                     jlib.system(command, verbose=1)
                     jlib.system( 'pwd', verbose=1)
                     if state.state_.macos:
-                        jlib.system( f'DYLD_LIBRARY_PATH={build_dirs.dir_so} {exe}', verbose=1)
+                        jlib.system( f'DYLD_LIBRARY_PATH={build_dirs.dir_so} ./test.cpp.exe', verbose=1)
                     else:
-                        jlib.system( f'{exe} {testfile}', verbose=1, env_extra=dict(LD_LIBRARY_PATH=build_dirs.dir_so))
+                        jlib.system( './test.cpp.exe', verbose=1, env_extra=dict(LD_LIBRARY_PATH=build_dirs.dir_so))
 
             elif arg == '--test-internal':
                 _test_get_m_command()
@@ -2727,7 +2764,7 @@ def main2():
                 references = '-r:System.Drawing -r:System.Windows.Forms' if state.state_.linux else ''
                 out = 'mupdfwrap_gui.cs.exe'
                 jlib.build(
-                        (f'{build_dirs.dir_mupdf}/scripts/mupdfwrap_gui.cs', mupdf_cs),
+                        ('scripts/mupdfwrap_gui.cs', mupdf_cs),
                         out,
                         f'"{csc}" -unsafe {references}  -out:{{OUT}} {{IN}}'
                         )
@@ -2737,8 +2774,7 @@ def main2():
                     # libraries.
                     jlib.fs_copy(f'{build_dirs.dir_mupdf}/thirdparty/zlib/zlib.3.pdf', f'{build_dirs.dir_so}/zlib.3.pdf')
                     # Note that this doesn't work remotely.
-                    out_rel = os.path.relpath( out, build_dirs.dir_so)
-                    jlib.system(f'cd {build_dirs.dir_so} && {mono} {out_rel}', verbose=1)
+                    jlib.system(f'cd {build_dirs.dir_so} && {mono} ../../{out}', verbose=1)
                 else:
                     jlib.fs_copy(f'{build_dirs.dir_mupdf}/thirdparty/zlib/zlib.3.pdf', f'zlib.3.pdf')
                     jlib.system(f'LD_LIBRARY_PATH={build_dirs.dir_so} {mono} ./{out}', verbose=1)
@@ -2827,18 +2863,14 @@ def main2():
                 # inside single quotes, doesn't work - we get error `The
                 # filename, directory name, or volume label syntax is
                 # incorrect.`.
-                if state.state_.openbsd:
-                    # Need system py3-llvm.
-                    jlib.system(f'"{sys.executable}" -m venv --system-site-packages {venv}', out='log', verbose=1)
-                else:
-                    jlib.system(f'"{sys.executable}" -m venv {venv}', out='log', verbose=1)
+                jlib.system(f'"{sys.executable}" -m venv {venv}', out='log', verbose=1)
                 if state.state_.windows:
                     command = f'{venv}\\Scripts\\activate.bat'
                 else:
                     command = f'. {venv}/bin/activate'
                 command += f' && python -m pip install --upgrade pip'
                 if state.state_.openbsd:
-                    jlib.log( 'Not installing libclang on openbsd; we assume py3-llvm is installed.')
+                    jlib.log( 'Not installing libclang on openbsd; we assume py3-llvm is installed')
                     command += f' && python -m pip install --upgrade swig'
                 else:
                     command += f' && python -m pip install{force_reinstall} --upgrade libclang swig'
diff --git a/jni/libmupdf/scripts/wrap/classes.py b/jni/libmupdf/scripts/wrap/classes.py
index bb857f113..4019da5ea 100644
--- a/jni/libmupdf/scripts/wrap/classes.py
+++ b/jni/libmupdf/scripts/wrap/classes.py
@@ -1151,6 +1151,20 @@ classextras = ClassExtras(
                         ),
                     ],
                 methods_extra = [
+                    ExtraMethod(
+                        f'std::vector<{rename.class_("fz_quad")}>',
+                        f'{rename.method("fz_page", "fz_search_page")}(const char* needle, int *hit_mark, int max)',
+                        f'''
+                        {{
+                            std::vector<{rename.class_("fz_quad")}> ret(max);
+                            ::fz_quad* hit_bbox = ret[0].internal();
+                            int n = {rename.ll_fn('fz_search_page')}(m_internal, needle, hit_mark, hit_bbox, (int) ret.size());
+                            ret.resize(n);
+                            return ret;
+                        }}
+                        ''',
+                        comment=f'/* Wrapper for fz_search_page(). */',
+                        ),
                     ExtraMethod(
                         f'{rename.class_("fz_document")}',
                         'doc()',
diff --git a/jni/libmupdf/scripts/wrap/cpp.py b/jni/libmupdf/scripts/wrap/cpp.py
index d3e588e8d..51ac5f1f3 100644
--- a/jni/libmupdf/scripts/wrap/cpp.py
+++ b/jni/libmupdf/scripts/wrap/cpp.py
@@ -923,10 +923,6 @@ def make_namespace_close( namespace, out):
 # and `std::vector<>` that work well enough for the generation of the
 # C++ API.
 #
-# We also define extra raw functions to aid SWIG-generated code. These
-# are implemented in C++, and should be excluded from the generated
-# windows_def file later on, otherwise we get link errors on Windows.
-#
 g_extra_declarations = textwrap.dedent(f'''
 
         #ifdef MUPDF_WRAP_LIBCLANG
@@ -953,58 +949,28 @@ g_extra_declarations = textwrap.dedent(f'''
         #include "mupdf/fitz.h"
         #include "mupdf/pdf.h"
 
-        /**
-        C++ alternative to `fz_lookup_metadata()` that returns a `std::string`
-        or calls `fz_throw()` if not found.
-        */
-        FZ_FUNCTION std::string fz_lookup_metadata2(fz_context* ctx, fz_document* doc, const char* key);
-
-        /**
-        C++ alternative to `pdf_lookup_metadata()` that returns a `std::string`
-        or calls `fz_throw()` if not found.
+        /** C++-specific alternative to `fz_lookup_metadata()` that returns a
+        `std::string` or calls `fz_throw()` if not found.
         */
-        FZ_FUNCTION std::string pdf_lookup_metadata2(fz_context* ctx, pdf_document* doc, const char* key);
+        FZ_FUNCTION std::string fz_lookup_metadata2( fz_context* ctx, fz_document* doc, const char *key);
 
-        /**
-        C++ alternative to `fz_md5_pixmap()` that returns the digest by value.
+        /** C++-specific alternative to `pdf_lookup_metadata()` that returns a
+        `std::string` or calls `fz_throw()` if not found.
         */
-        FZ_FUNCTION std::vector<unsigned char> fz_md5_pixmap2(fz_context* ctx, fz_pixmap* pixmap);
-
-        /**
-        C++ alternative to fz_md5_final() that returns the digest by value.
-        */
-        FZ_FUNCTION std::vector<unsigned char> fz_md5_final2(fz_md5* md5);
+        FZ_FUNCTION std::string pdf_lookup_metadata2( fz_context* ctx, pdf_document* doc, const char *key);
 
-        /** */
-        FZ_FUNCTION long long fz_pixmap_samples_int(fz_context* ctx, fz_pixmap* pixmap);
+        /** Convenience wrapper for `fz_md5_pixmap()`. */
+        FZ_FUNCTION std::vector<unsigned char> fz_md5_pixmap2(fz_context *ctx, fz_pixmap *pixmap);
 
-        /**
-        Provides simple (but slow) access to pixmap data from Python and C#.
-        */
-        FZ_FUNCTION int fz_samples_get(fz_pixmap* pixmap, int offset);
-
-        /**
-        Provides simple (but slow) write access to pixmap data from Python and
-        C#.
-        */
-        FZ_FUNCTION void fz_samples_set(fz_pixmap* pixmap, int offset, int value);
+        /** Mainly for use by Python/C# test code. */
+        FZ_FUNCTION long long fz_pixmap_samples_int(fz_context *ctx, fz_pixmap *pixmap);
 
-        /**
-        C++ alternative to fz_highlight_selection() that returns quads in a
-        std::vector.
-        */
-        FZ_FUNCTION std::vector<fz_quad> fz_highlight_selection2(fz_context* ctx, fz_stext_page* page, fz_point a, fz_point b, int max_quads);
+        FZ_FUNCTION int fz_samples_get(fz_pixmap *pixmap, int offset);
 
-        struct fz_search_page2_hit
-        {{
-            fz_quad quad;
-            int mark;
-        }};
+        FZ_FUNCTION void fz_samples_set(fz_pixmap *pixmap, int offset, int value);
 
-        /**
-        C++ alternative to fz_search_page() that returns information in a std::vector.
-        */
-        FZ_FUNCTION std::vector<fz_search_page2_hit> fz_search_page2(fz_context* ctx, fz_document *doc, int number, const char *needle, int hit_max);
+        /** Wrapper for fz_md5_final() that returns the digest by value. */
+        FZ_FUNCTION std::vector<unsigned char> fz_md5_final2(fz_md5* md5);
         ''')
 
 g_extra_definitions = textwrap.dedent(f'''
@@ -1071,44 +1037,6 @@ g_extra_definitions = textwrap.dedent(f'''
             fz_md5_final( md5, &ret[0]);
             return ret;
         }}
-
-        FZ_FUNCTION std::vector<fz_quad> fz_highlight_selection2(fz_context *ctx, fz_stext_page *page, fz_point a, fz_point b, int max_quads)
-        {{
-            {{
-                std::vector<fz_quad>    ret(max_quads);
-                int n;
-                fz_try(ctx)
-                {{
-                    n = fz_highlight_selection(ctx, page, a, b, &ret[0], max_quads);
-                }}
-                fz_catch(ctx)
-                {{
-                    n = -1;
-                }}
-                if (n >= 0)
-                {{
-                    ret.resize(n);
-                    return ret;
-                }}
-            }}
-            /* We are careful to only call `fz_throw()` after `ret`'s
-            destructor has been called. */
-            fz_throw(ctx, FZ_ERROR_GENERIC, "fz_highlight_selection() failed");
-        }}
-
-        FZ_FUNCTION std::vector<fz_search_page2_hit> fz_search_page2(fz_context *ctx, fz_document *doc, int number, const char *needle, int hit_max)
-        {{
-            std::vector<fz_quad>    quads(hit_max);
-            std::vector<int>        marks(hit_max);
-            int n = fz_search_page_number(ctx, doc, number, needle, &marks[0], &quads[0], hit_max);
-            std::vector<fz_search_page2_hit>    ret(n);
-            for (int i=0; i<n; ++i)
-            {{
-                ret[i].quad = quads[i];
-                ret[i].mark = marks[i];
-            }}
-            return ret;
-        }}
         ''')
 
 def make_extra( out_extra_h, out_extra_cpp):
@@ -1359,10 +1287,7 @@ def make_internal_functions( namespace, out_h, out_cpp, refcheck_if):
 
             FZ_FUNCTION void reinit_singlethreaded()
             {{
-                if (0)
-                {{
-                    std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): Reinitialising as single-threaded.\\n";
-                }}
+                std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): Reinitialising as single-threaded.\\n";
                 s_state.reinit( false /*multithreaded*/);
             }}
             ''')
@@ -3542,16 +3467,11 @@ def get_struct_fnptrs( cursor_struct, shallow_typedef_expansion=False, verbose=F
                     tt = state.get_name_canonical( t)
                     if verbose:
                         jlib.log('{tt.spelling=}')
-                    if (0
-                            or 'struct (unnamed at ' in tt.spelling
-                            or 'unnamed struct at ' in tt.spelling
-                            ):
-
+                    if not 'struct (unnamed at ' in tt.spelling:
                         # This is clang giving an unhelpful name to an
                         # anonymous struct.
                         if verbose:
-                            jlib.log( 'Avoiding clang anonymous struct placeholder: {tt.spelling=}')
-                    else:
+                            jlib.log( 'Avoiding clang struct (unnamed at ...) anonymous struct: {tt.spelling=}')
                         t = tt
                 if verbose:
                     jlib.log('Yielding: {cursor.spelling=} {t.spelling=}')
@@ -3744,14 +3664,6 @@ def class_wrapper_virtual_fnptrs(
         out_h.write(f'    FZ_FUNCTION void use_virtual_{cursor.spelling}( bool use=true);\n')
         out_cpp.write(f'FZ_FUNCTION void {classname}2::use_virtual_{cursor.spelling}( bool use)\n')
         out_cpp.write( '{\n')
-
-        out_cpp.write(f'    {refcheck_if}\n')
-        out_cpp.write(f'    if (s_trace_director)\n')
-        out_cpp.write( '    {\n')
-        out_cpp.write(f'        std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ": {classname}2::use_virtual_{cursor.spelling}(): this=" << this << " use=" << use << "\\n";\n')
-        out_cpp.write( '    }\n')
-        out_cpp.write( '    #endif\n')
-
         if extras.pod == 'inline':
             # Fnptr (in {classname}2) and virtual function (in {classname})
             # have same name, so we need qualify the fnptr with {classname} to
@@ -3791,8 +3703,8 @@ def class_wrapper_virtual_fnptrs(
         out_h.write( ');\n')
         out_cpp.write( ')\n')
         out_cpp.write( '{\n')
-        out_cpp.write(f'    std::cerr << "Unexpected call of unimplemented virtual_fnptrs fn {classname}2::{cursor.spelling}(): this=" << this << ".\\n";\n')
-        out_cpp.write(f'    throw std::runtime_error( "Unexpected call of unimplemented virtual_fnptrs fn {classname}2::{cursor.spelling}()");\n')
+        out_cpp.write(f'    std::cerr << "Unexpected call of unimplemented virtual_fnptrs fn {classname}2::{cursor.spelling}().\\n";\n')
+        out_cpp.write(f'    throw std::runtime_error( "Unexpected call of unimplemented virtual_fnptrs fn {classname}2::{cursor.spelling}().");\n')
         out_cpp.write( '}\n')
 
     out_h.write(  '};\n')
@@ -4470,7 +4382,6 @@ def cpp_source(
         check_regress,
         clang_info_version,
         refcheck_if,
-        debug,
         ):
     '''
     Generates all .h and .cpp files.
@@ -4495,8 +4406,6 @@ def cpp_source(
             `#if ... ' text for enabling reference-checking code. For example
             `#if 1` to always enable, `#ifndef NDEBUG` to only enable in debug
             builds, `#if 0` to always disable.
-        debug:
-            True if debug build.
 
     Updates <generated> and returns <tu> from clang..
     '''
@@ -4652,10 +4561,7 @@ def cpp_source(
 
     # Now parse.
     #
-    try:
-        index = state.clang.cindex.Index.create()
-    except Exception as e:
-        raise Exception(f'libclang does not appear to be installed') from e
+    index = state.clang.cindex.Index.create()
 
     header = f'{dir_mupdf}/include/mupdf/fitz.h'
     assert os.path.isfile( header), f'header={header}'
@@ -4767,8 +4673,6 @@ def cpp_source(
 
     out_hs.functions.write( textwrap.dedent(
             '''
-            #include "mupdf/extra.h"
-
             #include "mupdf/fitz.h"
             #include "mupdf/pdf.h"
 
@@ -4984,8 +4888,6 @@ def cpp_source(
                 'fz_samples_set',
                 'pdf_lookup_metadata2',
                 'fz_md5_final2',
-                'fz_highlight_selection2',
-                'fz_search_page2',
                 ):
             # These are excluded from windows_def because are C++ so
             # we'd need to use the mangled name in. Instead we mark them
@@ -5006,12 +4908,6 @@ def cpp_source(
             ):
         windows_def += f'    {fnname}\n'
 
-    if debug:
-        # In debug builds these are real fns, not macros, and we need to
-        # make them exported.
-        windows_def += f'    fz_lock_debug_lock\n'
-        windows_def += f'    fz_lock_debug_unlock\n'
-
     jlib.fs_update( windows_def, f'{base}/windows_mupdf.def')
 
     def register_fn_use( name):
diff --git a/jni/libmupdf/scripts/wrap/swig.py b/jni/libmupdf/scripts/wrap/swig.py
index d1ba655e6..f476e7c73 100644
--- a/jni/libmupdf/scripts/wrap/swig.py
+++ b/jni/libmupdf/scripts/wrap/swig.py
@@ -74,7 +74,7 @@ def build_swig(
     m = re.search( 'SWIG Version ([0-9]+)[.]([0-9]+)[.]([0-9]+)', t)
     assert m
     swig_major = int( m.group(1))
-    jlib.system( f'which "{swig_command}"', raise_errors=0)
+    jlib.system( f'which "{swig_command}"')
 
     # Create a .i file for SWIG.
     #
@@ -820,12 +820,6 @@ def build_swig(
             %ignore {rename.ll_fn('Memento_vasprintf')};
             %ignore {rename.fn('Memento_vasprintf')};
 
-            // These appear to be not present in Windows debug builds.
-            %ignore fz_assert_lock_held;
-            %ignore fz_assert_lock_not_held;
-            %ignore fz_lock_debug_lock;
-            %ignore fz_lock_debug_unlock;
-
             %ignore Memento_cpp_new;
             %ignore Memento_cpp_delete;
             %ignore Memento_cpp_new_array;
@@ -871,7 +865,6 @@ def build_swig(
                 %template(vectori) vector<int>;
                 %template(vectors) vector<std::string>;
                 %template(vectorq) vector<{rename.namespace_class("fz_quad")}>;
-                %template(vector_search_page2_hit) vector<fz_search_page2_hit>;
             }};
 
             // Make sure that operator++() gets converted to __next__().
@@ -914,7 +907,7 @@ def build_swig(
                                 #ifndef _WIN32
                                 << __PRETTY_FUNCTION__ << ": "
                                 #endif
-                                << "Converting C++ std::exception into {language} exception: " << e.what()
+                                << "Converting C++ std::exception into Python exception: " << e.what()
                                 << "\\n";
                     }}
                     SWIG_exception( SWIG_RuntimeError, e.what());
@@ -927,7 +920,7 @@ def build_swig(
                                 #ifndef _WIN32
                                 << __PRETTY_FUNCTION__ << ": "
                                 #endif
-                                << "Converting unknown C++ exception into {language} exception."
+                                << "Converting unknown C++ exception into Python exception."
                                 << "\\n";
                     }}
                     SWIG_exception( SWIG_RuntimeError, "Unknown exception");
diff --git a/jni/libmupdf/setup.py b/jni/libmupdf/setup.py
index f9dc7cf73..3f03a2aad 100755
--- a/jni/libmupdf/setup.py
+++ b/jni/libmupdf/setup.py
@@ -141,11 +141,7 @@ def mupdf_version():
     #
     # This also allows us to easily experiment on test.pypi.org.
     #
-    # We have to protect against the time component containing `.0` as this is
-    # prohibited by PEP-440.
-    #
-    tail = time.strftime(".%Y%m%d.%H%M").replace('.0', '.')
-    ret = base_version + tail
+    ret = base_version + time.strftime(".%Y%m%d.%H%M")
     #log(f'Have created version number: {ret}')
     return ret
 
@@ -451,16 +447,13 @@ https://mupdf.com/r/C-and-Python-APIs
 
 """
 
-with open(f'{root_dir()}/COPYING') as f:
-    license = f.read()
-
 mupdf_package = pipcl.Package(
         name = 'mupdf',
         version = mupdf_version(),
         root = root_dir(),
         summary = 'Python bindings for MuPDF library.',
         description = description,
-        classifier = [
+        classifiers = [
                 'Development Status :: 4 - Beta',
                 'Intended Audience :: Developers',
                 'License :: OSI Approved :: GNU Affero General Public License v3',
@@ -468,15 +461,13 @@ mupdf_package = pipcl.Package(
                 ],
         author = 'Artifex Software, Inc.',
         author_email = 'support@artifex.com',
-        home_page = 'https://mupdf.com/',
-        project_url = [
-            ('Documentation, https://mupdf.com/r/C-and-Python-APIs/'),
-            ('Source, https://git.ghostscript.com/?p=mupdf.git'),
-            ('Tracker, https://bugs.ghostscript.com/'),
-            ],
+        url_docs = 'https://mupdf.com/r/C-and-Python-APIs',
+        url_home = 'https://mupdf.com/',
+        url_source = 'https://git.ghostscript.com/?p=mupdf.git',
+        url_tracker = 'https://bugs.ghostscript.com/',
         keywords = 'PDF',
         platform = None,
-        license = license,
+        license_files = ['COPYING'],
         fn_build = build,
         fn_clean = clean,
         fn_sdist = sdist,
diff --git a/jni/libmupdf/source/html/html-layout.c b/jni/libmupdf/source/html/html-layout.c
index 02be2563e..a17b4e1c1 100644
--- a/jni/libmupdf/source/html/html-layout.c
+++ b/jni/libmupdf/source/html/html-layout.c
@@ -2420,7 +2420,6 @@ void fz_reset_story(fz_context *ctx, fz_story *story)
 	story->restart_draw.end = NULL;
 	story->restart_draw.end_flow = NULL;
 	story->rect_count = 0;
-	story->complete = 0;
 }
 
 static char *
diff --git a/jni/libmupdf/source/pdf/pdf-cmap.c b/jni/libmupdf/source/pdf/pdf-cmap.c
index 33072c1ab..405827cd8 100644
--- a/jni/libmupdf/source/pdf/pdf-cmap.c
+++ b/jni/libmupdf/source/pdf/pdf-cmap.c
@@ -718,12 +718,6 @@ pdf_map_range_to_range(fz_context *ctx, pdf_cmap *cmap, unsigned int low, unsign
 void
 pdf_map_one_to_many(fz_context *ctx, pdf_cmap *cmap, unsigned int low, int *values, size_t len)
 {
-	int *ovalues = values;
-	/* len is always restricted to <= 256 by the callers. */
-	int local[256];
-
-	assert(len <= 256);
-
 	/* Decode unicode surrogate pairs. */
 	/* Only the *-UCS2 CMaps use one-to-many mappings, so assuming unicode should be safe. */
 	if (len >= 2)
@@ -733,23 +727,16 @@ pdf_map_one_to_many(fz_context *ctx, pdf_cmap *cmap, unsigned int low, int *valu
 		 * with other chars. See bug 706131. */
 		for (i = 0, j = 0; i < len; i++, j++)
 		{
-			int hi = ovalues[i];
+			int hi = values[i];
 			if (hi >= 0xd800 && hi < 0xdc00 && i < len-1)
 			{
-				int lo = ovalues[i+1];
+				int lo = values[i+1];
 				if (lo >= 0xdc00 && lo < 0xe000)
 				{
 					hi = ((hi - 0xD800) << 10) + (lo - 0xDC00) + 0x10000;
 					i++;
 				}
 			}
-			if (values != local)
-			{
-				/* We can't change the callers data, so copy stuff in. */
-				if (j)
-					memcpy(local, values, sizeof(local[0]) * (j-1));
-				values = local;
-			}
 			values[j] = hi;
 		}
 		len = j;
diff --git a/jni/libmupdf/source/pdf/pdf-page.c b/jni/libmupdf/source/pdf/pdf-page.c
index 9de4aade1..d4db8e40f 100644
--- a/jni/libmupdf/source/pdf/pdf-page.c
+++ b/jni/libmupdf/source/pdf/pdf-page.c
@@ -605,9 +605,9 @@ fz_rect
 pdf_bound_page(fz_context *ctx, pdf_page *page, fz_box_type box)
 {
 	fz_matrix page_ctm;
-	fz_rect rect;
-	pdf_page_transform_box(ctx, page, &rect, &page_ctm, box);
-	return fz_transform_rect(rect, page_ctm);
+	fz_rect mediabox;
+	pdf_page_transform_box(ctx, page, &mediabox, &page_ctm, box);
+	return fz_transform_rect(mediabox, page_ctm);
 }
 
 fz_link *
@@ -638,7 +638,7 @@ void
 pdf_page_obj_transform_box(fz_context *ctx, pdf_obj *pageobj, fz_rect *outbox, fz_matrix *page_ctm, fz_box_type box)
 {
 	pdf_obj *obj;
-	fz_rect usedbox, tempbox, cropbox;
+	fz_rect usedbox, tempbox, mediabox;
 	float userunit = 1;
 	int rotate;
 
@@ -692,41 +692,38 @@ pdf_page_obj_transform_box(fz_context *ctx, pdf_obj *pageobj, fz_rect *outbox, f
 	/* Rotate */
 	*page_ctm = fz_pre_rotate(*page_ctm, -rotate);
 
-	/* Always use CropBox to set origin to top left */
-	obj = pdf_dict_get_inheritable(ctx, pageobj, PDF_NAME(CropBox));
-	if (!pdf_is_array(ctx, obj))
-		obj = pdf_dict_get_inheritable(ctx, pageobj, PDF_NAME(MediaBox));
-	cropbox = pdf_to_rect(ctx, obj);
-	if (fz_is_empty_rect(cropbox))
-		cropbox = fz_make_rect(0, 0, 612, 792);
-	cropbox.x0 = fz_min(cropbox.x0, cropbox.x1);
-	cropbox.y0 = fz_min(cropbox.y0, cropbox.y1);
-	cropbox.x1 = fz_max(cropbox.x0, cropbox.x1);
-	cropbox.y1 = fz_max(cropbox.y0, cropbox.y1);
-	if (cropbox.x1 - cropbox.x0 < 1 || cropbox.y1 - cropbox.y0 < 1)
-		cropbox = fz_unit_rect;
+	/* Always use MediaBox to set origin to top left */
+	mediabox = pdf_to_rect(ctx, pdf_dict_get_inheritable(ctx, pageobj, PDF_NAME(MediaBox)));
+	if (fz_is_empty_rect(mediabox))
+		mediabox = fz_make_rect(0, 0, 612, 792);
+	mediabox.x0 = fz_min(mediabox.x0, mediabox.x1);
+	mediabox.y0 = fz_min(mediabox.y0, mediabox.y1);
+	mediabox.x1 = fz_max(mediabox.x0, mediabox.x1);
+	mediabox.y1 = fz_max(mediabox.y0, mediabox.y1);
+	if (mediabox.x1 - mediabox.x0 < 1 || mediabox.y1 - mediabox.y0 < 1)
+		mediabox = fz_unit_rect;
 
-	/* Translate page origin of CropBox to 0,0 */
-	cropbox = fz_transform_rect(cropbox, *page_ctm);
-	*page_ctm = fz_concat(*page_ctm, fz_translate(-cropbox.x0, -cropbox.y0));
+	/* Translate page origin of MediaBox to 0,0 */
+	mediabox = fz_transform_rect(mediabox, *page_ctm);
+	*page_ctm = fz_concat(*page_ctm, fz_translate(-mediabox.x0, -mediabox.y0));
 }
 
 void
-pdf_page_obj_transform(fz_context *ctx, pdf_obj *pageobj, fz_rect *page_cropbox, fz_matrix *page_ctm)
+pdf_page_obj_transform(fz_context *ctx, pdf_obj *pageobj, fz_rect *page_mediabox, fz_matrix *page_ctm)
 {
-	pdf_page_obj_transform_box(ctx, pageobj, page_cropbox, page_ctm, FZ_CROP_BOX);
+	pdf_page_obj_transform_box(ctx, pageobj, page_mediabox, page_ctm, FZ_MEDIA_BOX);
 }
 
 void
-pdf_page_transform_box(fz_context *ctx, pdf_page *page, fz_rect *page_cropbox, fz_matrix *page_ctm, fz_box_type box)
+pdf_page_transform_box(fz_context *ctx, pdf_page *page, fz_rect *page_mediabox, fz_matrix *page_ctm, fz_box_type box)
 {
-	pdf_page_obj_transform_box(ctx, page->obj, page_cropbox, page_ctm, box);
+	pdf_page_obj_transform_box(ctx, page->obj, page_mediabox, page_ctm, box);
 }
 
 void
-pdf_page_transform(fz_context *ctx, pdf_page *page, fz_rect *cropbox, fz_matrix *ctm)
+pdf_page_transform(fz_context *ctx, pdf_page *page, fz_rect *mediabox, fz_matrix *ctm)
 {
-	pdf_page_transform_box(ctx, page, cropbox, ctm, FZ_CROP_BOX);
+	pdf_page_transform_box(ctx, page, mediabox, ctm, FZ_MEDIA_BOX);
 }
 
 static void
@@ -1137,9 +1134,9 @@ pdf_load_page_imp(fz_context *ctx, fz_document *doc_, int chapter, int number)
 		obj = pdf_dict_get(ctx, pageobj, PDF_NAME(Annots));
 		if (obj)
 		{
-			fz_rect page_cropbox;
+			fz_rect page_mediabox;
 			fz_matrix page_ctm;
-			pdf_page_transform(ctx, page, &page_cropbox, &page_ctm);
+			pdf_page_transform(ctx, page, &page_mediabox, &page_ctm);
 			page->links = pdf_load_link_annots(ctx, doc, page, obj, number, page_ctm);
 			pdf_load_annots(ctx, page, obj);
 		}
