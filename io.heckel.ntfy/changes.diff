diff --git a/app/build.gradle b/app/build.gradle
index 6bbb098..915d7fd 100644
--- a/app/build.gradle
+++ b/app/build.gradle
@@ -9,6 +9,10 @@ apply plugin: 'com.android.application'
 apply plugin: 'kotlin-android'
 apply plugin: 'com.google.gms.google-services'
 
+kotlin {
+    jvmToolchain(17)
+}
+
 android {
     namespace "io.heckel.ntfy"
     compileSdkVersion 35
@@ -31,6 +35,10 @@ android {
         buildFeatures {
             buildConfig true
         }
+
+        ndk {
+             abiFilters "arm64-v8a"
+        }
     }
 
     buildTypes {
@@ -73,6 +81,17 @@ android {
             '-Xjvm-default=all-compatibility' // https://stackoverflow.com/a/71234042/1440785
         ]
     }
+    Calendar origin = Calendar.getInstance()
+    origin.set(2021, Calendar.DECEMBER, 31, 23, 59)
+    Date d1 = origin.getTime()
+    Date d2 = new Date()
+    long minutes = (d2.getTime() - d1.getTime()) / 1000 / 60
+    def DateVersionCode = 2112312359 + minutes
+    android.applicationVariants.all { variant ->
+        variant.outputs.all { output ->
+            output.versionCodeOverride = DateVersionCode
+        }
+    }
 }
 
 // Disables GoogleServices tasks for F-Droid variant
diff --git a/app/src/main/AndroidManifest.xml b/app/src/main/AndroidManifest.xml
index 46b5eab..2bf5372 100644
--- a/app/src/main/AndroidManifest.xml
+++ b/app/src/main/AndroidManifest.xml
@@ -9,10 +9,16 @@
     <uses-permission android:name="android.permission.RECEIVE_BOOT_COMPLETED"/> <!-- To restart service on reboot -->
     <uses-permission android:name="android.permission.VIBRATE"/> <!-- Incoming notifications should be able to vibrate the phone -->
     <uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" android:maxSdkVersion="28"/> <!-- Only required on SDK <= 28 -->
-    <uses-permission android:name="android.permission.SCHEDULE_EXACT_ALARM"/> <!-- To reschedule the websocket retry -->
+    <uses-permission android:name="android.permission.SCHEDULE_EXACT_ALARM" android:maxSdkVersion="32"/> <!-- To reschedule the websocket retry -->
     <uses-permission android:name="android.permission.POST_NOTIFICATIONS"/> <!-- As of Android 13, we need to ask for permission to post notifications -->
     <uses-permission android:name="android.permission.REQUEST_IGNORE_BATTERY_OPTIMIZATIONS"/> <!-- Allows to ignore battery optimization without going to the settings -->
 
+    <queries>
+        <intent>
+            <action android:name="org.unifiedpush.android.connector.RAISE_TO_FOREGROUND" />
+        </intent>
+    </queries>
+
     <application
             android:name=".app.Application"
             android:allowBackup="true"
diff --git a/app/src/main/java/io/heckel/ntfy/up/BroadcastReceiver.kt b/app/src/main/java/io/heckel/ntfy/up/BroadcastReceiver.kt
index 46a0bcb..5df3067 100644
--- a/app/src/main/java/io/heckel/ntfy/up/BroadcastReceiver.kt
+++ b/app/src/main/java/io/heckel/ntfy/up/BroadcastReceiver.kt
@@ -1,7 +1,11 @@
 package io.heckel.ntfy.up
 
+import android.app.PendingIntent
 import android.content.Context
 import android.content.Intent
+import android.content.pm.PackageManager
+import android.os.Build
+import androidx.annotation.RequiresApi
 import io.heckel.ntfy.R
 import io.heckel.ntfy.app.Application
 import io.heckel.ntfy.db.Repository
@@ -32,7 +36,7 @@ class BroadcastReceiver : android.content.BroadcastReceiver() {
     }
 
     private fun register(context: Context, intent: Intent) {
-        val appId = intent.getStringExtra(EXTRA_APPLICATION) ?: return
+        val appId = getApplication(context, intent) ?: return
         val connectorToken = intent.getStringExtra(EXTRA_TOKEN) ?: return
         val app = context.applicationContext as Application
         val repository = app.repository
@@ -40,12 +44,13 @@ class BroadcastReceiver : android.content.BroadcastReceiver() {
         Log.d(TAG, "REGISTER received for app $appId (connectorToken=$connectorToken)")
         if (!repository.getUnifiedPushEnabled()) {
             Log.w(TAG, "Refusing registration because 'EnableUP' is disabled")
-            distributor.sendRegistrationFailed(appId, connectorToken, "UnifiedPush is disabled in ntfy")
+            // Action required: tell the app to not try again before an action as be done manually
+            // by the user
+            distributor.sendRegistrationFailed(appId, connectorToken, FailedReason.ACTION_REQUIRED)
             return
         }
         if (appId.isBlank()) {
             Log.w(TAG, "Refusing registration: Empty application")
-            distributor.sendRegistrationFailed(appId, connectorToken, "Empty application string")
             return
         }
         GlobalScope.launch(Dispatchers.IO) {
@@ -61,7 +66,8 @@ class BroadcastReceiver : android.content.BroadcastReceiver() {
                         distributor.sendEndpoint(appId, connectorToken, endpoint)
                     } else {
                         Log.d(TAG, "Subscription with connectorToken $connectorToken exists for a different app. Refusing registration.")
-                        distributor.sendRegistrationFailed(appId, connectorToken, "Connector token already exists")
+                        // Internal_error: try again with a new token
+                        distributor.sendRegistrationFailed(appId, connectorToken, FailedReason.INTERNAL_ERROR)
                     }
                     return@launch
                 }
@@ -99,7 +105,8 @@ class BroadcastReceiver : android.content.BroadcastReceiver() {
                     SubscriberServiceManager.refresh(app)
                 } catch (e: Exception) {
                     Log.w(TAG, "Failed to add subscription", e)
-                    distributor.sendRegistrationFailed(appId, connectorToken, e.message)
+                    // Try again when there is network
+                    distributor.sendRegistrationFailed(appId, connectorToken, FailedReason.NETWORK)
                 }
 
                 // Add to log scrubber
@@ -109,6 +116,81 @@ class BroadcastReceiver : android.content.BroadcastReceiver() {
         }
     }
 
+    /**
+     * Get application package name
+     */
+    private fun getApplication(context: Context, intent: Intent): String? {
+        return getApplicationAnd3(context, intent)
+        ?: getApplicationAnd2(intent)
+    }
+
+    /**
+     * Get application package name following AND_3 specifications.
+     */
+    private fun getApplicationAnd3(context: Context, intent: Intent): String? {
+        return if (Build.VERSION.SDK_INT >= 34) {
+            getApplicationAnd3SharedId(context, intent)
+        } else {
+            getApplicationAnd3PendingIntent(intent)
+        }
+    }
+
+    /**
+     * Try get application package name following AND_3 specifications for SDK>=34, with the shared
+     * identity.
+     *
+     * It fallback to [getApplicationAnd3PendingIntent] if the other application targets SDK<34.
+     */
+    @RequiresApi(34)
+    private fun getApplicationAnd3SharedId(context: Context, intent: Intent): String? {
+        return sentFromPackage?.also {
+            // We got the package name with the shared identity
+            android.util.Log.d(TAG, "Registering $it. Package name retrieved with shared identity")
+        } ?: getApplicationAnd3PendingIntent(intent)?.let { packageId ->
+            // We got the package name with the pending intent, checking if that app targets SDK<34
+            return if (Build.VERSION.SDK_INT >= 33) {
+                context.packageManager.getApplicationInfo(
+                    packageId,
+                    PackageManager.ApplicationInfoFlags.of(
+                        PackageManager.GET_META_DATA.toLong()
+                    )
+                )
+            } else {
+                context.packageManager.getApplicationInfo(packageId, 0)
+            }.let { ai ->
+                if (ai.targetSdkVersion >= 34) {
+                    android.util.Log.d(TAG, "App targeting Sdk >= 34 without shared identity, ignoring.")
+                    null
+                } else {
+                    packageId
+                }
+            }
+        }
+    }
+
+    /**
+     * Try get application package name following AND_3 specifications when running on
+     * a device with SDK<34 or receiving message from an application targeting SDK<34, with a pending
+     * intent.
+     *
+     * Always prefer [getApplicationAnd3SharedId] if possible.
+     */
+    private fun getApplicationAnd3PendingIntent(intent: Intent): String? {
+        return intent.getParcelableExtra<PendingIntent>(EXTRA_PI)?.creatorPackage?.also {
+            android.util.Log.d(TAG, "Registering $it. Package name retrieved with PendingIntent")
+        }
+    }
+
+    /**
+     * Try get the application package name using AND_2 specifications
+     */
+    @Deprecated("This follows AND_2 specifications. Will be removed.")
+    private fun getApplicationAnd2(intent: Intent): String? {
+        return intent.getStringExtra(EXTRA_APPLICATION)?.also {
+            android.util.Log.d(TAG, "Registering $it. Package name retrieved with legacy String extra")
+        }
+    }
+
     private fun unregister(context: Context, intent: Intent) {
         val connectorToken = intent.getStringExtra(EXTRA_TOKEN) ?: return
         val app = context.applicationContext as Application
diff --git a/app/src/main/java/io/heckel/ntfy/up/Constants.kt b/app/src/main/java/io/heckel/ntfy/up/Constants.kt
index 7db2680..60da3a2 100644
--- a/app/src/main/java/io/heckel/ntfy/up/Constants.kt
+++ b/app/src/main/java/io/heckel/ntfy/up/Constants.kt
@@ -17,5 +17,5 @@ const val EXTRA_APPLICATION = "application"
 const val EXTRA_PI = "pi"
 const val EXTRA_TOKEN = "token"
 const val EXTRA_ENDPOINT = "endpoint"
-const val EXTRA_MESSAGE = "message"
+const val EXTRA_FAILED_REASON = "reason"
 const val EXTRA_BYTES_MESSAGE = "bytesMessage"
diff --git a/app/src/main/java/io/heckel/ntfy/up/Distributor.kt b/app/src/main/java/io/heckel/ntfy/up/Distributor.kt
index b6f9cce..7b31a66 100644
--- a/app/src/main/java/io/heckel/ntfy/up/Distributor.kt
+++ b/app/src/main/java/io/heckel/ntfy/up/Distributor.kt
@@ -11,13 +11,9 @@ import io.heckel.ntfy.util.Log
 class Distributor(val context: Context) {
     fun sendMessage(app: String, connectorToken: String, message: ByteArray) {
         Log.d(TAG, "Sending MESSAGE to $app (token=$connectorToken): ${message.size} bytes")
-        val broadcastIntent = Intent()
-        broadcastIntent.`package` = app
-        broadcastIntent.action = ACTION_MESSAGE
-        broadcastIntent.putExtra(EXTRA_TOKEN, connectorToken)
-        broadcastIntent.putExtra(EXTRA_MESSAGE, String(message)) // UTF-8
-        broadcastIntent.putExtra(EXTRA_BYTES_MESSAGE, message)
-        context.sendBroadcast(broadcastIntent)
+        RaiseAppToForegroundFactory
+            .getInstance(context, app)
+            .raiseAndSend(connectorToken, message)
     }
 
     fun sendEndpoint(app: String, connectorToken: String, endpoint: String) {
@@ -39,15 +35,13 @@ class Distributor(val context: Context) {
         context.sendBroadcast(broadcastIntent)
     }
 
-    fun sendRegistrationFailed(app: String, connectorToken: String, message: String?) {
+    fun sendRegistrationFailed(app: String, connectorToken: String, reason: FailedReason) {
         Log.d(TAG, "Sending REGISTRATION_FAILED to $app (token=$connectorToken)")
         val broadcastIntent = Intent()
         broadcastIntent.`package` = app
         broadcastIntent.action = ACTION_REGISTRATION_FAILED
         broadcastIntent.putExtra(EXTRA_TOKEN, connectorToken)
-        if (message != null) {
-            broadcastIntent.putExtra(EXTRA_MESSAGE, message)
-        }
+        broadcastIntent.putExtra(EXTRA_FAILED_REASON, reason)
         context.sendBroadcast(broadcastIntent)
     }
 
